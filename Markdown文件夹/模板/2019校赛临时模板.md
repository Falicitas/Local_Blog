# 2019校赛临时模板

tags : 模板

[TOC]

    复习好计蒜客的知识点，然后写进博客。之后再整理kuangbin模板，代码都用自己的。最后用《计蒜客课程记录》来整理自己的模板



## 最短路
稀疏图和负权图用SPFA，稠密非负权图用dijkstra
dijkstra堆优化求最短路径：
```cpp
const int MAX_N = 10000;
const int MAX_M = 100000;
const int inf = 0x3f3f3f3f;
struct edge {
    int v, w, next;
} e[MAX_M];
int p[MAX_N], eid, n;
void mapinit() {
    memset(p, -1, sizeof(p));
    eid = 0;
}
void insert(int u, int v, int w) {  // 插入带权有向边
    e[eid].v = v;
    e[eid].w = w;
    e[eid].next = p[u];
    p[u] = eid++;
}
void insert2(int u, int v, int w) {  // 插入带权双向边
    insert(u, v, w);
    insert(v, u, w);
}

typedef pair<int, int> PII;

set<PII, less<PII> > min_heap;  // 用 set 来伪实现一个小根堆，并具有映射二叉堆的功能。堆中 pair<int, int> 的 second 表示顶点下标，first 表示该顶点的 dist 值
int dist[MAX_N];  // 存储单源最短路的结果
bool vst[MAX_N];  // 标记每个顶点是否在集合 U 中
bool dijkstra(int s) {
    // 初始化 dist、小根堆和集合 U
    memset(vst, 0, sizeof(vst));
    memset(dist, 0x3f, sizeof(dist));
    min_heap.insert(make_pair(0, s));
    dist[s] = 0;
    for (int i = 0; i < n; ++i){
        if (min_heap.size() == 0) {  // 如果小根堆中没有可用顶点，说明有顶点无法从源点到达，算法结束
            return false;
        }
        // 获取堆顶元素，并将堆顶元素从堆中删除
        auto iter = min_heap.begin();
        int v = iter->second;
        min_heap.erase(*iter);
        vst[v] = true;
        // 进行和普通 dijkstra 算法类似的松弛操作
        for (int j = p[v]; j != -1; j = e[j].next) {
            int x = e[j].v;
            if (!vst[x] && dist[v] + e[j].w < dist[x]) {
                // 先将对应的 pair 从堆中删除，再将更新后的 pair 插入堆
                min_heap.erase(make_pair(dist[x], x));
                dist[x] = dist[v] + e[j].w;
                min_heap.insert(make_pair(dist[x], x));
            }
        }
    }
    return true;  // 存储单源最短路的结果
}

```

## SPFA算法：
```cpp
bool inq[MAX_N];
int d[MAX_N];  // 如果到顶点 i 的距离是 0x3f3f3f3f，则说明不存在源点到 i 的最短路
void spfa(int s) {
    memset(inq, 0, sizeof(inq));
    memset(d, 0x3f, sizeof(d));
    d[s] = 0;
    inq[s] = true;
    queue<int> q;
    q.push(s);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = false;
        for (int i = p[u]; i != -1; i = e[i].next) {
            int v = e[i].v;
            if (d[u] + e[i].w < d[v]) {
                d[v] = d[u] + e[i].w;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = true;
                }
            }
        }
    }
}
```

### 特殊生成树例题：
圣诞节快到了，蒜头君准备做一棵大圣诞树。这棵树被表示成一组被编号的结点和一些边的集合，树的结点从1到n编号，树的根永远是1
。每个结点都有一个自身特有的数值，称为它的权重，各个结点的权重可能不同。对于一棵做完的树来说，每条边都有一个价值$v_e$，
若设这条边e连接结点$i$和结点$j$，且$i$为$j$的父结点（根是最老的祖先），则该边的价值$v_e=
s_j×w_e$，$s_j$表示结点$j$的所有子孙及它自己的权重之和，$w_e$ 表示边$e$的权值。
现在蒜头君想造一棵树，他有$m$条边可以选择，使得树上所有边的总价值最小，并且所有的点都在树上，因为蒜头君喜欢大树。
解：其实就是节点1到所有点的距离之和再分别乘上权值。题目就不贴了。

## 次短路
分两种：
同一道例题：
### 可经过重复点的次短路：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 10000;
const int MAX_M = 100000;
const int INF = 0x3f3f3f3f;
const double eps = 1e-6;

typedef pair <double,int> PII;

int n,m;

struct E
{
    double w;
    int v,next;
} edge [MAX_M];

int p [MAX_N] = {0},eid;

void init()
{
    memset(p,-1,sizeof(p));
    eid = 0;
}

void insert1(int u, int v, double w)
{
    edge[eid].v=v;
    edge[eid].w=w;
    edge[eid].next=p[u];
    p[u]=eid++;
}

void insert2(int u, int v, double w)
{
    insert1(u,v,w);
    insert1(v,u,w);
}

set<PII, less<PII>>min_heap;
int vis[MAX_N]= {0};
double dist[MAX_N]= {0},dist2[MAX_N]= {0};
bool dijkstra(int s)
{
    memset(vis,0,sizeof(vis));
    for(int i=0; i<MAX_N; i++)
    {
        dist[i]=dist2[i]=INF;
    }
    min_heap.insert(make_pair(0,s));
    dist[s]=0;
    for(int i=0; i<n; i++)
    {
        if(min_heap.empty())
        {
            return false;
        }
        auto it=min_heap.begin();
        int u=it->second;
        vis[u]=true;
        min_heap.erase(it);
        for(int j=p[u]; j=-1; j=edge[j].next)
        {
            int v=edge[j].v;
            if(!vis[v]&&dist[u]+edge[j].w-dist[v]<eps)  ///eps判断很容易出错，记得留意此处
            {
                min_heap.erase(make_pair(dist[v],v));
                dist2[v]=dist[v];
                dist[v]=dist[u]+edge[j].w;
                min_heap.insert(make_pair(dist[v],v));
            }
        }
    }
    return true;
}
struct P
{
    int x,y,ind;
} point[MAX_N];
int main()
{
    init();
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",& point[i].x,& point[i].y);
        point[i].ind=i;
    }
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        int x1=point[u].x,y1=point[u].y,x2=point[v].x,y2=point[v].y;
        double dis=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
        insert2(u,v, dis);
    }
    if(dijkstra(1)){
        if(INF-dist2[n]<eps){
            printf("-1\n");
        }
        else{
            printf("%f\n",dist2[n]);
        }
    }
    return 0;
}

```
### 不可经过同一点：（AC代码）
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 405;
const int MAX_M = 200050;
const int inf = 0x3f3f3f3f;
const double eps = 1e-6;
int n,m;

int eid,p[MAX_N];

struct P
{
    int x;
    int y;
}point[MAX_N];

struct E
{
    double w;
    int v,next;
}edge[MAX_M];

void init()
{
    memset(p,-1,sizeof(p));
    eid = 0;
}

int AC_road[MAX_N] = {0};   ///做枚举删减
int AC_length = 0;///AC_road长度
int newly_road[MAX_N] = {0};///1~n的点最后被谁更新。起点是n，终点一定是1

void insert1(int u,int v,double w)
{
    edge[eid].v = v;
    edge[eid].w = w;
    edge[eid].next = p[u];
    p[u] = eid++;
}

void insert2(int u,int v,double w)
{
    insert1(u,v,w);
    insert1(v,u,w);
}

double dis_ret(P a,P b)
{
    double x1 = a.x, x2 = b.x;
    double y1 = a.y, y2 = b.y;
    double x = x1 - x2;
    double y = y1 - y2;
    return sqrt(x * x + y * y);
}

double minn = inf;

double dist[MAX_N] = {0};
bool inq[MAX_N] = {0};


void SPFA(int s,int to,int from)///次短路SPFA
{
    for(int i=0;i<MAX_N;i++) dist[i] = inf;
    memset(inq,0,sizeof(inq));
    queue<int> q;
    q.push(s);
    inq[s] = 1;
    dist[s] = 0;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for(int i=p[u];i!=-1;i=edge[i].next){
            int v = edge[i].v;
            if(to==v&&from==u) continue;///次短路增加判别
            if(dist[v]>dist[u] + edge[i].w){
                dist[v] = dist[u] + edge[i].w;
                if(!to){    ///如果是第一次求最短路，记录更改
                    newly_road[v] = u;
                }
                if(!inq[v]){
                    q.push(v);
                    inq[v] = 1;
                }
            }
        }
    }
}

int main()
{
    init();
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        int x,y;
        cin>>x>>y;
        point[i].x = x;
        point[i].y = y;
    }
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        double w = dis_ret(point[u],point[v]);
        insert2(u,v,w);
    }
    SPFA(1,0,0);
    int cur = n;///从n点回溯到1，找出最短路径经过的边
    AC_road[AC_length++] = cur;
    while(cur!=1){
        AC_road[AC_length++] = newly_road[cur];
        cur = newly_road[cur];
    }

    for(int i=0;i<AC_length-1;i++){
        SPFA(1,AC_road[i],AC_road[i+1]);
        minn = min(minn,dist[n]);
    }
    if(inf-minn<eps) cout<<-1<<endl;
    printf("%.2f",minn);
    return 0;
}

```
#### 例题：
你可以在银行进行各种货币的兑换，例如，你可以用1美元兑换0.5英镑，1英镑兑换10.0法郎，1法郎兑换0.21美元。这样，你就可以用**初始的1美元兑换出1.05美元**。像这样通过换汇获得盈利的过程被称为“套汇”。给定若干货币之间的汇率兑换比例，你需要判断其中是否存在“套汇"。
解法：在一个套汇路线中，如果初始货币为1单位，则最终“套汇”路线就意味着边权乘积大于1的环。根据对数的基本运算规则：
log（ab）=log（a）+log（b）
如果我们把每条边权取对数，则环上所有边权对数的累加和大于0。因此，如果我们把边权进行如下的对应转换：
n_w=-log（w）
接下来只需要在转换后的图中判断是否存在负环就可以了。
#### 例题：
有个蘑菇精想要成仙，但是他必须要收集10000个精灵宝石，不过他要是有花精灵的泪水，就只要8000个精灵宝石就可以了，或者如果他有花精灵的血滴，就只要5000个精灵宝石便可以成仙了。蘑菇精可以和森林里的其他精灵交换东西，但是修为等级差距过大的交换会影响修炼蘑菇精就跑到花精灵那里，向他索要泪水或血滴，花精灵要他用精灵宝石来换，或者替他弄来其他的东西，他可以降低价格。蘑菇精于是又跑到其他地方，其他精灵也提出了类似的要求，或者直接用精灵宝石换，或者找到其他东西就可以降低价格。不过蘑菇精没必要用多样东西去换一样东西，因为这不会得到更低的价格。
蘑菇精现在很需要你的帮忙，让他用最少的精灵宝石帮助他成仙。另外他要告诉你的是，在这个森林里，交换东西，修为差距超过一定限制的两个精灵之间不会进行任何形式的直接接触，包括交易，否则会影响修炼。
蘑菇精是外来精灵，所以可以不受这些限制。但是如果他和某个修为等级较低的精灵进行了交易，修为等级较高的的精灵有可能不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。
为了方便起见，我们把所有的物品从1开始进行编号，成仙也看作一个物品，并且编号总是1。每个物品都有对应的代价P，主人精灵的修为等级L，以及一系列的替代品T，和该替代品所对应的“优惠”。如果两个精灵修为等级差距超过了M，就不能“间接交易”。你必须根据这些数据来计算出蘑菇精最少需要多少精灵宝石才能成仙。输入格式
第一行是两个整数M，N（1≤M≤20，1≤N≤20000），依次表示修为等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P，L，X（X<N），依次表示该物品的代价、主人精灵的修为等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和“优惠价格”。（X≤200000）。
输出格式
对于每个测试数据，在单独一行内输出最少需要的精灵宝石数。

换物品（代价转换求最小路），多创一个0点，然后SPFA
上个代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
int L[200010];
using namespace std;
int MAXN=70000;
int p[70000];
bool inq[70000];
long long d[200010];
int INF=0x3f3f3f3f;
int eid;
int n,m;
struct edge
{
    int v;
    int next;
    int w;
}e[500000];

int edgeinsert(int wei,int u,int v)
{
    e[eid].v=v;
    e[eid].w=wei;
    e[eid].next=p[u];
    p[u]=eid++;
}
int init()
{
    memset(p,-1,sizeof(p));
    eid=0;  
}

void SPFA(int st,int xiuwei)
{
    memset(inq,false,sizeof(inq));
    memset(d,INF,sizeof(d));
    d[st]=0;
    inq[st]=true;
    queue<int>q;
    q.push(st);
    while(!q.empty()) 
    {
        int u=q.front();
        q.pop();
        inq[u]=false;
        for(int i=p[u];i!=-1;i=e[i].next)
        {
            int v=e[i].v;
            if((L[v]>=xiuwei)&&(L[v]<=xiuwei+m)&&(d[u]+e[i].w<d[v]))
            {
            d[v]=d[u]+e[i].w;
            if(!inq[v])
            {   
                q.push(v);
                inq[v]=true; 
            }
            }
        }
    }
return;
}


int main()
{
    init();
    cin>>m>>n;
    for(int i=1;i<=n;i++)
    {   
        int p,x;
        cin>>p>>L[i]>>x;
        edgeinsert(p,0,i);
        while(x--)
        {   int a,b;
            cin>>a>>b;
            edgeinsert(b,a,i);
        }
    }
    long long ans=INF;
    for(int i=L[1];i+m>=L[1];i--)
    {
    SPFA(0,i);
    ans=min(d[1],ans);
    }
    cout<<ans;
    return 0;
}
```

## 差分约束系统
因此我们可以将每个变量xi作为一个顶点，对于约束条件x；-xi≤k，连接一条边权为k的有向边<i，j>。我们再增加一个**超级源s**，s连向其余每个顶点，边权均为0。对这个图执行单源最短路算法，如果程序正常结束，那么得到的最短路答案数组d；就是满足条件的一组解；若图中存在负环，则该不等式组无解。
例题：
虽然蒜头君并没有多少钱，但是蒜头君办了很多张银行卡，共有n张，以至于他自己都忘记了每张银行卡里有多少钱了。
他只记得一些含糊的信息，这些信息主要以下列三种形式描述：
1.银行卡a比银行卡b至少多c元。
2.银行卡a比银行卡b至多多c元。
3.银行卡a和银行卡c里的存款一样多。
但是由于蒜头君的记忆有些差，他想知道是否存在一种情况，使得银行卡的存款情况和他记忆中的所有信息吻合。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX_N = 10050;
const int MAX_M = 10050;
int n,m;
struct E
{
    int v,w,next;
}edge[MAX_M];

int p[MAX_N] = {0};
int eid;
void init()
{
    memset(p,-1,sizeof(p));
    eid = 0;
}

void insert1(int u,int v,int w)
{
    edge[eid].v = v;
    edge[eid].w = w;
    edge[eid].next = p[u];
    p[u] = eid++;
}
int dist[MAX_N];
int num_q[MAX_N] = {0};
int inq[MAX_N];
int SPFA(int s)
{
    memset(dist,0x3f,sizeof(dist));
    memset(num_q,0,sizeof(num_q));
    memset(inq,0,sizeof(inq));
    queue<int> q;
    inq[s] = 1;
    q.push(s);
    dist[s] = 0;
    num_q[s]++;
    while(!q.empty()){
        int u = q.front();
        q.pop();
        inq[u] = 0;
        for(int i=p[u];i!=-1;i=edge[i].next){
            int v = edge[i].v;
            if(dist[v]>dist[u] + edge[i].w){
                dist[v] = dist[u] + edge[i].w;
                if(!inq[v]){
                    if(n==num_q[v]) return 0;
                    num_q[v]++;
                    q.push(v);
                    inq[v] = 1;
                }
            }
        }
    }
    return 1;
}

int main()
{
    init();
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) insert1(0,i,0);
    for(int i=1;i<=m;i++){
        int numm,a,b,c;
        cin>>numm;
        if(numm==1){
            cin>>a>>b>>c;
            insert1(a,b,-c);
        }
        else if(numm==2){
            cin>>a>>b>>c;
            insert1(b,a,c);
        }
        else{
            cin>>a>>b;
            insert1(a,b,0);
            insert1(b,a,0);
        }
    }
    if(SPFA(0)) puts("Yes");
    else puts("No");
    return 0;
}
```
## floyd:
```cpp
const int inf = 0x3f3f3f3f;
int g[MAX_N][MAX_N];  // 算法中的 G 矩阵

// 初始化 g 矩阵
void init() {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (i == j) {
                g[i][j] = 0;
            } else {
                g[i][j] = inf;
            }
        }
    }    
}

// 插入一条带权有向边
void insert(int u, int v, int w) {
    g[u][v] = w;
}

// 核心代码
void floyd() {
    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (g[i][k] + g[k][j] < g[i][j]) {
                    g[i][j] = g[i][k] + g[k][j];
                }
            }
        }
    }    
}


```
### 例题：奶牛的比赛
有n只奶牛参加比赛，其中有m对关系，在每对关系（a，b）中，奶牛a一定可以赢奶牛b。如果奶牛a可以赢奶牛b，奶牛b可以赢奶牛c，则奶牛a一定可以赢奶牛c，也就是说，关系具有传递性。确保给定的关系之间没有矛盾。问一共有多少只奶牛可以确定最终的排名。
思路：我们将Floyd 算法的代码进行一些调整，矩阵G保存的结果为：
·Gi.；=0：奶牛i不确定能否赢奶牛j
·Gii=1：奶牛一定可以赢奶牛j
代码：
```cpp
for (int k = 0; k < n; ++k) {
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (g[i][k] && g[k][j]) {
                g[i][j] = true;
            }
        }
    }
}
```
算完以后，如果有a只奶牛一定可以赢奶牛i，奶牛一定可以赢b只奶牛，且a+b=n-1，则说明奶牛i的排名是确定的。

## 欧拉回路：直接贴一道题。都有双向边，所以一定能走完全部图。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX_N = 50010;
struct E
{
    int v,next;
}edge[MAX_N<<1];
int n,m,a,b,eid,p[MAX_N];
bool vis[MAX_N<<1];

void init()
{
    memset(p,-1,sizeof(p));
    eid = 0;
}

void insertx(int u,int v)///
{
    edge[eid].v = v;
    edge[eid].next = p[u];
    p[u] = eid++;
}
void dfs(int u)///euler_dfs写法
{
    for(int i=p[u];i!=-1;i=edge[i].next){
        if(!vis[i]){    ///这个是euler_判别vis[i]
            vis[i] = 1;
            dfs(edge[i].v);
        }
    }
    cout<<u<<'\n';///最后输出u
}
int main()
{
    init();
    cin>>n>>m;
    while(m--){
        cin>>a>>b;
        insertx(a,b);
        insertx(b,a);
    }
    dfs(1);
    return 0;
}


```


# 线段树
## 排名前b：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 100050;
int state[MAX_N];
int c[MAX_N];               ///用于维护[1~a]的树状数组。将询问q存储起来，按a排序



int ans[MAX_N];

struct node
{
    int a;
    int b;
    int pos;
}Q[MAX_N];

bool cmp(const node &n1,const node &n2)
{
    return n1.a<n2.a;
}

int lowbit(int x)
{
    return x&(-x);
}

int getsum(int x)
{
    int res = 0;
    for(;x;x-=lowbit(x))
    {
        res+=c[x];
    }
    return res;
}

int change(int x)
{
    for(x;x<=MAX_N;x+=lowbit(x))
    {
        c[x]++;
    }
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&state[i]);
    }
    for(int i=1;i<=m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        Q[i].a = a;
        Q[i].b = b;
        Q[i].pos = i;
    }
    sort(Q+1,Q+m+1,cmp);
    int cnt =1;
    for(int i=1;i<=n;i++){
        change(state[i]);
        while(Q[cnt].a==i)         ///因为结构体已经按a排过序了，所以一定会遍历所有结构体（a从低到高）
        {
            ans[Q[cnt].pos] = getsum(Q[cnt].b);
            cnt++;
        }
    }
    for(int i=1;i<=m;i++){
        printf("%d\n",ans[i]);
    }
    return 0;
}

```
## 比自己小(大)问题：
```cpp
#include<bits/stdc++.h>
using namespace std;
///目前不会，日后解决
const int MAX_N = 500024;
int C[MAX_N+5],Rank[MAX_N],a[MAX_N],n;

int lowbit(int x)
{
    return x&(-x);
}

void change(int x,int sum){
	for(;x<=n;x+=lowbit(x))
        C[x]+=sum;
}

int getsum(int x){
	int res = 0;
	for(;x;x-=lowbit(x))
	   res+=C[x];
	   return res;
}

int main(){
	scanf("%d",&n);
	for(int i=2;i<=n;i++){
        scanf("%d",&a[i]);
	}
	a[1] = 0;
	for(int i = n;i>=1;i--){
	    int L = 1,R = n;
            while(L<=R){
                int mid=(L+R)/2;
                int t=getsum(mid);
                if(t+1+a[i]<=mid) R=mid-1;
                else L=mid+1;
            }
            Rank[i]=L;
            change(L,1);
	}
	for(int i = 1;i<=n;i++){
		printf("%d\n",Rank[i]);
	}

	return 0;
}
```

# 基础dp
## 滚动dp
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAX_N = 100;
const int MAX_M = 10;
int state[MAX_N + 1];//i行状态
//int dp[MAX_N + 1][1 << MAX_M][1 << MAX_M];//i行状态为j i-1行状态为k时包含的最多1的个数
int dp[2][1 << MAX_M][1 << MAX_M];//i行状态为j i-1行状态为k时包含的最多1的个数

bool not_intersect(int now, int prev) {
    return (now & prev) == 0;
}

bool fit(int now, int flag) {
    return (now | flag) == flag;
}
bool ok(int x) {
    // 行内自己不相交，返回true
    return ( (x & (x / 2)) == 0 ) && ( (x & (x / 4)) == 0 );
}

int calc(int now) {
    int s = 0;  // 统计 now 的二进制形式中有多少个 1
    while (now) {
        s += (now & 1);  // 判断 now 二进制的最后一位是否为 1，如果是则累加
        now >>= 1;  // now 右移一位
    }
    return s;
}

int main() {
    int n, m;
    cin >> n >> m;
    // 初始化所有数组
    memset(state, 0, sizeof(state));
    memset(dp, 0, sizeof(dp));

    char c;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < m; ++j) {
            int flag;
            cin >> c;
            if(c == 'P') {
                flag = 1;
            } else {
                flag = 0;
            }
            state[i] |= (1 << j) * flag;  // 将 (i,j) 格子的状态放入 state[i] 中，state[i] 表示第 i 行的可选格子组成的集合
        }
    }

    //处理第1行边界
    for(int j = 0; j < (1 << m); ++j) {
        if (!ok(j) || !fit(j, state[1])) {  // 如果第1行状态不合法则不执行后面的枚举
                continue;
        }

        int cnt = calc(j);
        dp[1%2][j][0] = cnt;

    }

    //处理第2行边界
    for(int j = 0; j < (1 << m); ++j) {
        if (!ok(j) || !fit(j, state[2])) {  // 如果第2行状态不合法则不执行后面的枚举
                continue;
        }

        int cnt = calc(j);
        for (int k = 0; k < (1 << m); ++k) {
            if (ok(k) && fit(k, state[1]) && not_intersect(j, k)) {  // 第1行合法且第2行 第1行不冲突
                dp[2%2][j][k]= dp[1%2][k][0] + cnt;  // 更新当前行、当前状态的最优解
            }
        }
    }

    //正常处理
    for (int i = 3; i <= n; ++i) {
        for (int j = 0; j < (1 << m); ++j) {  // 枚举当前行的状态
            if (!ok(j) || !fit(j, state[i])) {  // 如果当前行状态不合法则不执行后面的枚举
                continue;
            }

            int cnt = calc(j);  // 统计当前行一共选了多少个格子

            for (int k = 0; k < (1 << m); ++k) {//上行状态为k
                if (!ok(k) || !fit(k, state[i-1])) {  // 如果上行状态不合法则不执行后面的枚举
                    continue;
                }

                for(int l = 0; l < (1 << m); ++l) {//上上行状态为l
                    if (!ok(l) || !fit(l, state[i-2])) {  // 如果上上行状态不合法则不执行后面的枚举
                        continue;
                    }

                    if(not_intersect(j, k) && not_intersect(k, l) && not_intersect(j, l)) {
                        dp[i%2][j][k]= max(dp[i%2][j][k], dp[(i - 1)%2][k][l] + cnt);  // 更新当前行、当前状态的最优解
                    }
                }

            }
        }
    }

    int ans = 0;  // 保存最终答案
    for (int i = 0; i < (1 << m); ++i) {
            for(int j = 0; j < (1 << m); ++j)
                ans = max(ans, dp[n%2][i][j]);  // 枚举所有状态，更新最大值
    }
    cout << ans << endl;
    return 0;
}

```
## 子集dp：（伪）
```cpp
for (int t = 1; t < (1 << n); t++) {  // 枚举当前状态
     dp[t] = t满足条件（G） ? ans : inf;  // 判断当前状态是否是回文，如果是回文则步骤数为 1
    for(int i = t; i; i = (i - 1) & t) { // 枚举 t 的所有子集
        dp[t] = min(dp[t], dp[i] + dp[t ^ i]);  // 更新当前状态的解的最小值
    }					///↑这个是两个互补的子集
}
printf("%d\n", dp[(1 << n) - 1]);  // 输出最终答案
///答案是全员枚举的下标，dp[(1<<n) - 1];

```
## 背包
```cpp
01:
for (int i = 1; i <= N; ++i) {
    for (int j = 0; j <= V; ++j) {
        if(j >= w[i]) {
            dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j]);
        }
        else {
            dp[i][j] = dp[i-1][j];
        }
    }
}
01空间优化：
for (int i = 1; i <= n; ++i)
    for (int j = v; j >= w[i]; --j)			///空间优化过的，从背包大小V开始
        dp[j] = max(dp[j - w[i]] + v[i], dp[j]);	
完全背包：
for (int i = 1; i <= n; ++ i)
    for (int j = c[i]; j <= v; ++ j)
        dp[j] = max(dp[j - c[i]] + w[i], dp[j]);
多重背包：
14，可以写成1+2+4+7

LIS：
const int MAX_N = 10;

int main()
{
    int ans[MAX_N], a[MAX_N]={0,2,1,5,3,6,4,6,3}, dp[MAX_N], n=8;  // ans 用来保存每个 dp 值对应的最小值，a 是原数组
    int len; // LIS chccc

    ans[1] = a[1];
    len = 1;
    for (int i = 2; i <= n; ++i) {
        if (a[i] > ans[len]) {
            ans[++len] = a[i];
        } else {
            int pos = lower_bound(ans + 1, ans + len + 1, a[i]) - ans;
            /**要知道，这里的ans数组并不是最终的最长上升子序列
            ***而它也能求出结果
            ***因为当二分找到的是ans[len]的值时，那么此时的a[i]与ans[len]有着同样的dp值
            ***那么修改了ans[len]之后，ans[len]的值就变小了，符合我们的预期
            ***如果二分修改的是前面的值，不影响结果，因为序列仍在继续往前走
            **/
            ans[pos] = a[i];
        }
    }
    cout << len << endl;  // len 就是最终结果
    return 0;
}

LCS:
	string a,b;
    memset(dp,0,sizeof(dp));
    cin>>a>>b;
    int lena = a.size();
    int lenb = b.size();
   	///注意，这里从1开始，一直到lena，lenb，最终答案就是dp[lena][lenb]
    for(int i=1;i<=lena;++i){
        for(int j=1;j<=lenb;++j){
            if(a[i-1]==b[j-1]){
             	dp[i][j] = dp[i-1][j-1]+1;   
            }
            else{
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    cout<<dp[lena][lenb]<<endl;


```
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=1000000;
int prime[MAXN+1];
void getPrime(){
    memset(prime,0,sizeof(prime));
    for(int i=2;i<=MAXN;i++){
        if(!prime[i])prime[++prime[0]]=i;
        for(int j=1;j<=prime[0]&&prime[j]<=MAXN/i;j++){
            prime[prime[j]*i]=1;
            if(i%prime[j]==0) break;
        }
    }
}
long long factor[100][2];
int fatCnt;
int getFactors(long long x){
    fatCnt=0;
    long long tmp=x;
    for(int i=1;prime[i]<=tmp/prime[i];i++){
        factor[fatCnt][1]=0;
        if(tmp%prime[i]==0){
            factor[fatCnt][0]=prime[i];
            while(tmp%prime[i]==0){
                factor[fatCnt][1]++;
                tmp/=prime[i];
            }
            fatCnt++;
        }
    }
    if(tmp!=1){
        factor[fatCnt][0]=tmp;
        factor[fatCnt++][1]=1;
    }
    return fatCnt;
}

int main()
{
    getPrime();
    int i = getFactors(12308760);
    cout<<i<<endl;
    for(int j=0;j<i;j++)
        cout<<"Prime "<<j<<":"<<factor[j][0]<<",cnt="<<factor[j][1]<<endl;
    return 0;
}
```