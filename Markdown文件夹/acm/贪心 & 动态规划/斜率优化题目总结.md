# 斜率优化题目总结

```cpp
ll getans(int i,int j){return ;}

ll Y(int j){return ;}

ll X(int j){return ;}

//bool slope(int j2,int j1,int i){return 1LL * (Y(j2) - Y(j1)) * (X(j1) - X(i)) >= 1LL * (Y(j1) - Y(i)) * (X(j2) - X(j1));}//下凸包
bool slope(int j2,int j1,int i){return 1.0 * (Y(j2) - Y(j1)) / (X(j2) - X(j1)) + eps > 1.0 * (Y(j1) - Y(i)) / (X(j1) - X(i));}//爆long long时换这个。eps=1e-13
//bool slope(int j2,int j1,int i){return 1.0 * (Y[j2] - Y[j1]) / (X[j2] - X[j1]) + eps > 1.0 * (Y[j1] - Y[i]) / (X[j1] - X[i]);}


void solve1()//状态i的斜率单增且b[j]单增：单调队列可弹队首
{
    static int q[maxn];
    int head = 1,tail = 1;//[)
    q[tail++] = f[0] = 0;
    REP(i,1,n){
        while(head+1<tail && getans(i,q[head]) >= getans(i,q[head+1])){
            head++;
        }
        f[i] = getans(i,q[head]);

        while(head+1<tail && slope(q[tail-2],q[tail-1],i)){
            tail--;
        }
        q[tail++] = i;
    }
}

void solve2()//状态i的斜率不单调但b[j]单增：单调栈凸包上二分
{
    static int stk[maxn];
    int top = 1;
    stk[top++] = f[0] = 0;
    REP(i,1,n){
        int l = 1,r = top-1;
        while(l<r){
            mid = l + (r - l) / 2;
            if(getans(i,stk[mid])>=getans(i,stk[mid+1])) l = mid + 1;
            else r = mid;
        }
        f[i] = getans(i,stk[l]);
        while(top>2 && slope(stk[top-2],stk[top-1],i)){
            top--;
        }
        stk[top++] = i;
    }
}

//cdq分治版本。用单调栈

bool cmp(int i,int j)
{
    return b[i] < b[j];
}

void solve(int i)
{
    int l = 1,r = top - 1;
    if(top<=1) return ;
    while(r - l > 4){
        int m1 = l + (r - l) / 3;
        int m2 = r - (r - l) / 3;
        if(getans(i,stk[m1])>getans(i,stk[m2]))
            l = m1;
        else
            r = m2;
    }
    while(l<=r) g[i] = min(g[i],getans(i,stk[l++]));
}

void cdq(int l,int r)
{
    static int L[maxn],R[maxn];
    if(l>=r) return ;
    int cl,cr;
    cl = cr = 0;
    int mid = l + (r - l) / 2;
    cdq(l,mid);
    REP(i,l,mid) if(!h[i][1]) L[++cl] = h[i][0];
    REP(i,mid+1,r) if(h[i][1]) R[++cr] = h[i][0];
    top = 1;
    sort(L+1,L+cl+1,cmp),sort(R+1,R+cr+1,cmp);
    for(int i=1,j=1;j<=cr;j++){
        while(i<=cl&&...){//some comparing factors
            if(top>1&&b[stk[top-1]]==b[L[i]]) top--;//stk中的最头元素是top-1. =_=
            while(top>2&&slope(stk[top-2],stk[top-1],L[i])) top--;
            stk[top++] = L[i++];
        }
        solve(R[j]);
    }
    cdq(mid+1,r);
}

```
## 总结
维护下凸包当且仅当opt=min，是由于dp[i]在右式中在b的位置上，且系数为+。决策集中绝不选到上凸点。
在非负整数域中, l + (r - l) / 2 == (l + r) / 2 !!
测试过了！不要在怀疑了！斜率优化的X都是单增的，也不要怀疑了！所有系数都给斜率。
快半个圆的凸包经常存在qwq。正确求法应用三分。
关于X(i)的设值：让其都单增（随着决策点的顺序添加单增），然后直接套slope。故当三分时，K(i)取什么值，是否单调都无所谓了，反正求得是截距最小(最大)，而不管正负，都是切点最小（自己可以比划一下）。
cdq分治会把斜率给整成随机的，若套了cdq，则只能在凸包上三分了。此时斜率如何变化与维护下凸包，三分无关。
怕爆long long，用long double的斜率式。加个eps，呈直线的也踢掉，不会是最优的。
在cdq排序时可能遇到b[]相同的情况。这时则让不那么优的排前面。比如opt=min时，让值大的，即没那么优的排前面。
对cdq的理解：~~核心问题应该是当前只有g[0]有值，如何保证其他点正常更新8。其实可以想象一开始的1~cnt中，1~mid左区间的所有状态的决策集中已经有0了，即它们在更新时必定被0更新过。同理..~~
正确用法是：先对左区间cdq分治，保证左区间的状态全部被它们各自该有的决策集更新完。之后在对右区间做cdq分治前，先把左区间的决策贡献给右区间，保证右区间偏右的元素能被同为右区间的已经更新的一些可用的偏左的状态所更新。在拆迁队中，可以直接cdq分治两侧，原因是贡献的点的状态已经是最优了。。而未被贡献的点也不会相互贡献给对方。。（同时无）
在cdq左区间到右区间的代码间，不要搞什么中途return的“优化”骚操作。免得把右区间的分治给跳过了。。


> darkbzoj链接后面可以直接改搜bzoj题号

##        一些题目

### [BZOJ2726][SDOI2012]任务安排

$f[i] = min\{f[j] + (sf[i] - sf[j]) * st[i] + S * (sf[n] - sf[j])\}$
即
$f[i] = min\{f[j] + st[i] * sf[i] - st[i] * sf[j] + S * sf[n] - S * sf[j]\}$。

> $Y(j) = f[j] - S * sf[j], X(j) = sf[j],K(i) = st[i]$。斜率不一定单增，$st[i+1]$可能小于$st[i]$。而$X(j)$妥妥单增，故在下凸包上二分答案：由getans来比较，slope来维护下凸包，解决。

### [bzoj3675][Apio2014]序列分割

$f[i][k] = max\{f[j][k-1] + (s[i] - s[j]) * (s[n] - s[i])\}$
即
$f[i][k] = max\{f[j][k-1] + s[j] * s[i] - s[j] * s[n] + s[i] * s[n] - s[i] * s[i]\}$

> $Y(j,k) = f[j][k] - s[j] * s[n],X(j,k) = s[j],K(i) = -s[i]$。斜率单减，X(j)单增，单调队列维护上凸包。空间小，故X，Y由表达式来求，且使用滚动dp。

### [bzoj4518][Sdoi2016]征途

$f[i][k] = min\{f[j][k-1] + m * (s[i] - s[j]) * (s[i] - s[j])\}$(最后加上最后一段$m * (s[n] - s[i])^2$，减去$s[n] * s[n]$)
即
$f[i][k] = min\{f[j][k-1] + m * s[i] * s[i] + m * s[j] * s[j] - 2 * s[i] * s[j]\}$

> $Y(j,k) = f[j][k] + m * s[j] * s[j],X(j) = s[j],K(i) = 2 * s[i]$。斜率单增，$X(j)$单增，单调队列维护下凸包。记得将最后一段加上。

### [bzoj2149]拆迁队

几个问题：
1、$ij$项为：$-d[j] * i$。
试令$X[j] = d[j]$，维护$X[j]$单增的下凸包。
2、$d[L[cl]]<=d[R[cr]]$加点
看清楚，d[]作为X轴，（直觉上）决策点不能在状态点右侧。
3、$cmp$。
让不这么优的放前面。
4、爆$long long$
有可能。在斜率那。改换成long double
$g[i] = g[j] + (2 * a[j] + i - j) * (i - j - 1) / 2 + a[i] + b[i]$

强约束：$f[j] + 1 = f[i]，d[j] <= d[i] (f[j] + 1 =  f[i]$不代表j就能转移给$i$，可能$j$的$a[j]$值很高，但排的前而已。)
负数的问题也解决了，原先的solve里当栈空的时候也会更新值。。。结果出现了负数。栈空时不更新。同时栈顶为$stk[top-1]$。。不要搞错了。

> $Y(j) = g[j] - (j+1) * a[j] + j * (j + 1) / 2,X(j) = d[j], K(i) = -i$，cdq按X(j)单增下凸包维护。三分靠getans评判。

### [bzoj1492][NOI2007]货币兑换Cash

为什么不卖掉一部分金券来增加现金，或者花掉一部分现金换取金券：
1. 首先倘若分天卖金券，必定存在一天卖，以同等的比例，能卖更高的价格。即$A_i * tot + B_i * tot$最大。同时分天买金券，必定有一天花相同价钱买入金券的量最大的。
2. 由于一天可以多次交易，而且交易的价格都是按照$A_i,B_i$来计算的，即现金与期货等价交换。第i天能赚到的最多钱等价于第i天能换到最多的金券数量。故直接用f[i]表示金额的大小即可。

总结：可以这么理解，f[i]表示当前能赚的最多的钱，可以把第j天的所有钱换成金券（那么中间就不操作），然后在第i天全部卖掉。

$f[i] = X[j] * A[i] + Y[j] * B[i].$

> $Y(j) = \frac{f[j]}{A[j]*rate[j]+B[j]},X(j) = \frac{rate[j]*f[j]}{A[j]*rate[j]+B[j]},opt = max.$cdq维护上凸包。

### [bzoj3672][Noi2014]购票

树结构+斜率优化的题目。

假定每个点的可走距离lim[i]为无穷大，则从该点沿祖先的所有点的决策均可以做，复杂度$O(n^2)$。考虑到**以u节点为根节点的所有子树，均可以从u->fa[u]->...->1的一条链状态转移过来**，便考虑点分治。
先继续对u节点的祖先连通块进行分治，即让祖先的所有状态求出。后把u节点的子树加入决策中，按dis[u] - lim[u]从大到小排序（该值越大，可选择的决策点就越少）。遍历u上的祖先链，维护决策下凸包，让子树的状态更新完后，再对子树进行分治。推荐将根节点也划入待更新的状态中，代码写的简洁。