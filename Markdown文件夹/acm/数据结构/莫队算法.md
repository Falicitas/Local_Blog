# 莫队算法

利用 **双指针** 和 **巧妙的查询排序** 的算法。

基于的原理：假设对区间$[l,r]$的信息已获取完毕，如果区间$[l,r+1],[l,r-1],[l-1,r],[l+1,r]$的基于$[l,r]$的信息获取复杂度是 **平凡** 的$O(1)$（不宜过高，不然复杂度爆炸），这时对查询的区间$[ql,qr]$中按$ql$ **块编号** 为第一关键字，按$qr$ **下标编号** 为第二关键字进行排序，可以达到复杂度为$O(\frac{n^2}{S}+mS)$，$n$为序列长度，$S$为块长，$m$为查询次数。

大概代码的形式：

```cpp
void add(int x)
{
    cnt[x]++;
    if(cnt[x]==1)ans++;
}

void del(int x)
{
    cnt[x]--;
    if(cnt[x]==0)ans--;
}

//在获取答案时：init l = r = 0
while(l>q[i].l) add(a[--l]);
while(r<q[i].r) add(a[++r]);
while(l<q[i].l) del(a[l++]);
while(r>q[i].r) del(a[r--]);
```



关于复杂度的计算：对于查询左区间$ql$在同一块，由于右区间$qr$是连续向右的，复杂度为$O(n)$。块的个数为$\frac{n}{S}$，故块间查询复杂度为$O(\frac{n^2}{S})$。由于块内的$ql$可能在块间反复横跳，故真复杂度为$O(\frac{n^2}{S} + mS)$。故设计块长需要根据这类复杂度来计算。比如上面的复杂度，设计块长$S = \frac{n}{\sqrt{m}}$（不过据测试$S = \frac{n}{\sqrt{\frac{2m}{3}}}$会快些）。

一类卡常的技巧按奇偶性排序：

```cpp
bool cmp(node a,node b)
{
    return pos[a.l]^pos[b.l]?pos[a.l]<pos[b.l]:pos[a.l]&1?a.r<b.r:a.r>b.r;//pos[a.l]为块编号
    
}
//另一版本
bool operator<(const node&rhs) const
{
    return (l / S) == (rhs.l / S) ? (((l / S) & 1) ? r < rhs.r : r > rhs.r) : ((l / S) < (rhs.l / S));
}
```

怎么理解呢，对于奇数块来说右指针顺序向右走；对于偶数块来说右指针顺序向左走，避免每到下一个块先往回走再向右走。理论能快一倍。

## 可修莫队

加一维时间，即有三维坐标$(l,r,time)$，之后按照$ql$的块为第一关键字，$qr$的块为第二关键字，$time$按从小到大排。令块的大小为$S = n^{\frac{2}{3}}$，复杂度可简化至$O(n^\frac{5}{3})$（易证）。

另有不太像样的奇偶性排序（至少保证了一定的连续性）（然鹅基本没快多少。。）：

```cpp
bool operator<(const node&rhs)
{
    if(l / S == rhs.l / S){
        if((l / S) & 1){
            if(r / S == rhs.r / S){
                if((r / S) & 1) return time < rhs.time;
                else return time > rhs.time;
            }
            else{
                return r / S < rhs.r / S;
            }
        }
        else{
            if(r / S == rhs.r / S){
                if((r / S) & 1) return time > rhs.time;
                else return time < rhs.time;
            }
            else{
                return r / S > rhs.r / S;
            }
        }
    }
    else return l / S < rhs.l / S;
}
```

~~别用了~~还是正常板子就行。

## 树上莫队

不知道是否有其他查询。这里的树上莫队指的是查询一条路径的信息。

首先求该树的dfs序，每个点按遍历顺序入队两次。对于路径$<u,v>$来说，每次查询点$u,v$的 **第一个** dfn。

可以发现在移动指针的过程中，有些点被遍历了两次。具体地，不在路径上的点会被遍历0次or2次，即代表没经过这个点，故在移动指针时加入`vis[]`表示当前区间有无遍历过某点，异或一下状态即可。

但上述查询的正确仅在 $u$ 或 $v$ 为端点的lca。当$u$ and $v$ 不作为lca时，起始节点（默认为dfn序小的节点）会被遍历两次，而lca则是没被遍历到。故当$u$ and $v$ 不作为lca，将lca和起始节点加入到运算中， **最后撤销** 掉即可。

## 一些习题

### P1972 [SDOI2009]HH的项链

现在这道题莫队做不了了。上面的莫队就是根据这题讲的。

考虑离线做法：由于同种颜色只考虑一个，现只考虑从右到左第一个出现的同种颜色的位置。那么只需将查询区间按右排序，遇到之前遇到的颜色则在BIT上将原位置的1摘除，同时当前位置为1，这就保证了BIT上的1都代表不同颜色，按上述排序也保证前面区间的查询是正确的。对于区间$[l,r]$来说，只需要`sum(r) - sum(l-1)`即可。

### P1903 [国家集训队]数颜色 / 维护队列

可修莫队模板。

### P3604 美好的每一天

由于答案仅跟字母的奇偶性有关，考虑异或：

将字母按$1<<i$编号，发现对于一个区间能够集体飞升，要不整体异或为$0$，要不为$2^k$。由于该题的 **前缀异或和** 具有可加性，故考虑$a_i = \bigoplus\limits_{j=1}^{i}c_j$，然后套莫队，注意区间是$[l-1,r]$中选两个数异或，新加入（或减去）的$a_p$与跟$a_p$差一位的$a_q$或$a_p$对应的方案异或。

### 大爷的字符串题

求区间$[l,r]$的众数的出现次数。

只需要在莫队的基础上，加一个$num[i]$表示出现次数为$i$的数有多少个，这样就能维护众数了。

### P4396 [AHOI2013]作业

1e5的数据，$O(n\sqrt{m}logn)$过不了。

细想莫队的实现本质，通过$O(n\sqrt{m})$的移动来实现$O(m)$的查询，是这样一个数据结构。那么需要一个快速修改，低速查询的ds：值域分块。将值域分块后，修改可以$O(1)$，查询均摊至$O(m\sqrt{n})$。总复杂度$O(n\sqrt{m} + m\sqrt{n})$

### P4462 [CQOI2018]异或序列

与 **美好的每一天** 一样的思路，~~水紫~~。

### P4688 [Ynoi2016]掉进兔子洞

莫队+bitset（真的是敢写敢过，由于是1e5级别，可将$\frac{1e5}{64}$视作与$\sqrt{n}$同一级别）

先将序列离散化，令$a[i]$等于小于等于$a[i]$的元素个数。对于一个区间$[l,r]$，新加入一个元素$a[c]$，则在bitset上的$a[c] - cnt[a[c]]$位置上附上1，这样就实现了带权bitset，可以用来和其他两个区间进行与操作以 **取到最少相同元素个数** （秒啊）。

### P5355 [Ynoi2017]由乃的玉米田

莫队+bitset

对于减法，只需要`cur & (cur>>x)`，看是否有1即可。

对于加法，存一个按值域reverse的bitset，则`cur & (rev >> (N - x))`，$N$为值域上界。

对于乘法，暴力枚举出现因数即可。

对于除法：对于大于$M = \sqrt{n}$的，直接暴力枚举，复杂度为$O(\sqrt{n})$；对于小于等于$M$的，另外有一个trick：对于单个$x$，$O(n)$考虑`pre[i]`为$i$上次出现的位置，$res[j]$为$[l,j]$中存在两个数满足条件的最右的$l$。只要查询区间$[ql,qr]$满足$ql<=res[qr]$即为`true`（这个trick的原理就是能够在$O(n)$的复杂度下找到以某个点为右端点的最短满足条件的区间）。总复杂度为$O(n\sqrt{n})$。

### P5268 [SNOI2017]一个简单的询问

由于对于区间$[l,r]$某元素$x$的个数满足差分性质`cnt[r][x] - cnt[l-1][x]`，故将问题转化一下：

令$g(r,x)$为$x$元素在$[1,r]$出现的次数，原问题转化为$\sum g(r_1,x)g(r_2,x) - \sum g(r_1,x)g(l_2-1,x) - \sum g(l_1-1,x)g(r_2,x) + \sum g(l_1-1,x)g(l_2-1,x)$，然后莫队一下就好。

### CF940F Machine Learning

可修莫队加小结论。

问一个区间的数出现次数的mex，带修改。移动指针是带修莫队的基本操作。考虑暴力查询：

假设区间$[l,r]$的出现次数的mex为$x$，有$1+2+\dots+x-1<=r-l+1$，可知$x$是根号级别的，直接暴力查就是了。

### P4689 [Ynoi2016]这是我自己的发明

「遥远的国度」和「一个简单的询问」的结合。

首先是上个树剖。如果没有换根操作的话，实际是查询两个子树代表的区间的$\sum\limits_{x}g(l_1,r_1,x)g(l_2,r_2,x)$的值。将该查询拆成前缀和的形式，然后拆公式即可。

考虑换根。由「遥远的国度」可知换根实际查询的是一个子树的 **补集** 。将查询区间分类讨论，可知最多分成9次查询。最后压线过了。

### CF1436E Complicated Computations

关于该题的其他信息看同名的题解。

关于求区间mex：

增加：当当前mex答案=x且添加进来的就为x，则要while向上找（这个可以用值域分块优化）。

删除：当删掉的x小于当前mex，则让mex = x。

