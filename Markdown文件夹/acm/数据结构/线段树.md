# 线段树

**Lazy-tag**:当遇到查询的区间割裂了当前查询节点代表的区间，即查询区间不包含当前的区间时，当前区间的lazy-tag就下放给左右两区间，保证查询的正确。在编程上就把下传操作放在访问左右节点之上。

**冷知识**:由于每一行最多只有两个蓝色区间（需要向下递归的节点）和两个红色区间（lazy-tag放到这里停止的节点）, 因此线段树区间修改的自带常数为 4。即logn层，每层至多访问4个节点，故复杂度为$O(4logn)$。

### 多个lazy-tag

考虑打标记运算的优先级, 优先级高的先下传。具体可以看习题[维护序列](#P2023 [AHOI2009] 维护序列)。

### 应用范围

> 统计量可合并（可表示成左右区间答案的合并）
> 修改量可合并（修改量可叠加）
> 通过修改量可直接修改统计量

> ⼀句话: **满足区间加法即可使用线段树维护信息**

    如何设计线段树，其实只在于如何去维护一个区间块，使其满足区间相加，以及$O(1)$至多$O(logn)$修改一段区间块。

## 一些习题

### 例题1

给定一个n个节点的堆，第i号结点的左儿子编号为2i, 右
儿子为2i+1。
有m个操作，分为2类，每个结点初始权值为0
操作1将u，v路径上的所有点权值加上w
操作2：询问第x号结点的权值

做法：由于树上路径长都是logn级别，直接暴力更新就可

### 例题二 P1471 方差

区间修改后维护区间的方差值。将方差公式拆开后发现需要维护区间和与区间平方和。设计平方和（立方和）时考虑$x_1^2 + x_2^2 + ... + x_n^2 \to (x_1+k)^2 + (x_2+k)^2 + ... + (x_n+k)^2 $时多了$ 2 * k * (x_1 + x_2 + ... + x_n) + nk^2$，在区间平方和放lazy时这样去设计。区间平方和显然满足统计量可合并。

### 例题三

给出 A[], 要求支持:
1 询问 A[l..r] 中最大的数
2 删除 A[x], 并且 x+1 以后的元素整体前移
3 在末尾增加⼀个数

（这道题没有链接）先按询问次数扩充区间长度。线段树中多维护一个变量与询问，这个变量维护区间点存在的个数（当然可以单独写个BIT维护）。然后对询问的l,r二分，找到正确的l'与r'。复杂度为$O((n+m)log^2(n+m))$

### 例题四 矩形面积并

对于扫描线代码无down:只源于+1-1的边一一匹配，同时查询的是整个区间边的长度。两个条件一个不符合都不行。可以这样想：删除的边对应的区间点都是之前为正数（即被访问过的）点。同时这些被修改的点逐一往上统计，节点1便是整个区间的长。（尝试写个down和query，使其满足任意删边均可查出可选区间的长度）~~艹，写不出来~~

写down的时候，左右节点的len受更下层节点的影响。下层节点更新，才能保证区间加法的正确性。~~emm不会说这是自己写不出来找的借口~~

找模板来写吧。

### 例题五 [bzoj1593][Usaco2008 Feb]Hotel 旅馆

对于每个节点，维护lm，rm，sm三个值。值得注意的是当左区间的lm(ls)==左区间长度，那么lm(p)的值应为lm(ls) + lm(rs)。其余几个量同理。

询问找下标，分情况讨论：

对于第一层区间$p\in[1,n]$：

> (1) lm >= D,则选择端点1。
> (2) sm >= D,分三种情况：在左区间，在中间，在右区间。
> 询问左右区间；返回值按左中右判断。
> (3) 不存在这样的区间，返回0。

由于线段树共O(logn)层，每层不超过4个区间同时处理，故单次查询复杂度为O(4logn)。

### 例题六 CF718C Sasha and Array

一个线性公式的题目。合并答案并无问题，左右两个子区间的答案合并。但区间修改时不能O(1)计算区间信息。
考虑维护矩阵。能发现对一个块的每个矩阵*m个构造矩阵，维护的答案等于块中的每个矩阵之和*m个构造矩阵。即块维护矩阵之和，放lazy-tag时块的修改量就是*m个构造矩阵。问题解决。

从这个问题上摸清楚如何设计线段树：查询时合并答案如何满足区间加法，区间修改时如何满足[现有的区间块信息sum + k] -> [新区间块sum']可以被计算。

### 例题七 2018 ACM-ICPC 上海大都会 H A Simple Problem with Integers

跟循环节有关系的题目。先有个结论：对于1~p-1的每一个数，取平方都会遇到一个循环节，而最大的那个循环节是所有循环节的公倍数。所以在块未被更新最大入环距离的次数前便暴力更新每个节点，否则可以整块更新(先预处理一遍sum[]值，sum[]数组大小取决于最长循环节长度)。

由于在部分块尚未进入循环节时，需要对块对应的每个点进行暴力修改。学到了如何从区间修改变逐点修改（具体可以看代码）。

建议（写本文的明天）先学龟兔赛跑算法，然后再做题。另外线段树还有一个类似的黑题，估计明天一天学线段树。

### P3747 [六省联考2017]相逢是问候

**线段树+扩欧**

发现当某一位的操作次数叠到若干次时，由于扩欧的模数往上叠时不断减小至1，继续操作值不发生改变。

#### 引理1

对一个数$a_0$进行$a_{i+1} = \varphi(a_i)$的操作次数至多为$logn$。

粗略证明：当n为奇数时，其必由若干个两两互质的奇素因子组成、、对于质数$p,\varphi(p^n) = p^{n-1} * (p-1) \%2 = 0$，故$\varphi(n)$必有素因子$2$，即$\varphi(n)$为偶数。

当$n$为偶数时，素因子$2$中拿一个$2$献祭（x），变成$1$，$n>=2\varphi(n)$，，

所以复杂度为$O(logn)$。

回到线段树上的修改，对某个数不断叠加操作次数，将模数往上放的过程中还需要注意幂次与模幂次的模数的大小关系、、同时若采用 上帝与集合的正确用法 的dfs来做的话，线段树单词修改+扩欧叠幂次+快速幂的复杂度高达$O(log^3n)$、、

由于能确定每一层的模数$P,\varphi(P),\varphi(\varphi(P)),...$，除了最后一层幂是$a[i]$外（虽然实际操作不需要担心），，取模的底都是$c$，故去预处理以$c$为底的若干幂次，按模数分组、、当底数$c$叠加幂次叠到若干值到需要取模，即$(i,j),i$为$c$的幂，$j$为模数分组，$c^i\geq mod[j]$时，用一数组记录该状态代表$(i,j)$需要加模数、、

可以发现$i$的取值高达$1e8$，遂分块暴力处理，分$c^{k_1*10000+k_2}$两组$k_1,k_2\in[0,10000]$，则指数$i = (i/10000)*10000 + (i \% 10000)$、、两组$k_1,k_2$分别记录与模数的关系，合并是否加模数的信息、、这时取幂运算转为$O(1)$、、总复杂度为$O(logn\sqrt{n}) + nlog^2n)$

### [BZOJ3589] 动态树

树剖+线段树，主要讲线段树。涉及的操作是对若干个区间进行覆盖操作，被覆盖的元素统计起来，若元素被覆盖若干次仅记一次。统计完后清空。

首先是覆盖操作：

对于完整块来说，将覆盖值$cov(p)$赋值于$sum(p)$，然后向上传递，最后查询仅需查询$cov(1)$；

对于清除操作，只需在节点$1$打上清除标记，下放的时候**优先下放清除标记，将左右子区间的cov(),覆盖标记给清除**，再下放其他标记，以保证后面来的覆盖标记能准确地下放。

### P2023 [AHOI2009] 维护序列

区间乘+区间加。这道题在打标记的过程中始终要保持下放给子区间（其对应值为$v$）的原则为$val = tag_{\times} \times val + tag_{+}$。故对于一个完整区间的打标记：

> 当区间+一个数v，$tag_{+} += v$
>
> 当区间*一个数v，$tag_{\times} *= v,tag_{+} *= v$

### P6327 区间加区间sin和

$\sin (a+x) = \sin(a)\cos(x)+\sin(x)cos(a)$

$cos(a+x) = \cos(a)\cos(x) - \sin(a)\sin(x)$

利用公式维护$\sin ,\cos$就可以了。

### P5482 [JLOI2011]不等式组

解不等式，在对应可行区间赋值就行。

### P3792 由乃与大母神原型和偶像崇拜

下面一题的弱化版。有一种利用hash的正确率高解法，比较简单就不记录了，题解区有。

### P5278 算术天才⑨与等差数列

一段序列重排后是公差为k的等差序列当且仅当：

>区间$[l+1,r]$维护差分$\operatorname{gcd} = k$（注意这里没有$[l,l]$。区间gcd维护时记得要和$a[l]$gcd一次）
>
>区间$\max - \min = k * (r - l)$
>
>区间内数不出现同样的。用set维护最近相同数位置pre。

这里讲讲如何维护pre。

$S[i]$存放数$v$离散后的值$i$对应区间的位置关系。比如数$114514$对应$S[3]$，其在区间的位置为$1,14,514$，则$S[3] = \{1,14,514\}$。

将$v_1\rightarrow v_2$，修改位置为$x$，那么发生pre改变的位置就有：$x$，$v_1$在x位置的后缀的位置$y$，$v_2$在x位置的后缀的位置$z$。将这几个位置push到待修改位置的数组里，最后修改即可。修改前记得维护$S[i]$，修改时写一个函数$pre()$简洁很多。

具体的实现可参照下面一题的代码。

### P6617 查找 Search

问区间中有无$a_x+a_y = w$的组合。

用线段树维护互补的pre位置即可。这里维护的互补，是互补区间最小的。比如w=4，区间为$1,3,3,3,3$，那么只有最前面的3需要维护pre = 1,其余的等于0就可以了（因为大区间若合法，其必定对应一个合法的子区间）这样能保证修改操作是常数级别。由于要保证这样的性质有一些细节，具体看代码中的函数`pre()`。

### P5069 [Ynoi2015]纵使日薄西山

严格上不属于线段树的题目。但用到了（或者必须要用到）能常数修改的性质。

对于一个极长单调区间来说，极大值必然选到，然后每隔一点就需要操作一个点（即极长区间内操作点的奇偶性跟极大值）。根据这个性质，就可以根据奇偶性用树状数组直接统计一个极长单调区间的答案贡献。

如何记录一段区间是极长单调区间？只需要用set维护所有的极值点即可。

修改一个值，会影响至多5个最近极值点（包括其本身）的答案统计，同时会影响相邻两点及其本身是否会成为（或者撤销）极值点的状态。

还有一些细节，比如连续区间相同的数，开头的数若大于前面的数则让其为极大值，尾部的数若小于后面的数则让其为极小值（这个在代码中`check(int x)`一个if-else就处理完了6种情况。细品）具体看代码和[扶苏大佬的博客](https://www.cnblogs.com/yifusuyi/p/11108521.html)。代码注释的很清楚了。

### T161038 查狄伦12T 1954年型

先讲讲50pt做法。

首先式子可以写成$(Amax_{l,r}-Amin_{l,r})(Bmax_{l,r}-Bmin_{l,r})(Cmax_{l,r}-Cmin_{l,r})$，这意味着，当新增了一个点，若一类区间（以A序列举例）左边的极差整体加上了x，即可以线性去维护它。比如$1,2,3,4,5,6$，当前维护的极差（和）为$5,4,3,2,1,0$，此时新加入$7$，那么前面的极差和要加上一个增量x。那么现在维护A序列极差a，B序列极差b，C序列极差c，A序列极差 * B序列极差，A序列极差 * C序列极差，B序列极差 * C序列极差，A序列极差 * B序列极差 * C序列极差（这里在线段树上维护的都是节点区间的和）；当修改某区间[l,r]的极值时（还是以A序列为例，极差增加x），a += (r - l + 1) * x,ab += bx,ac += cx,abc += abx。当对于一个位置$r$的三个序列都修改好时，此时的abc值表示以当前$r$为右端点，新增的区间$[l,r],l\in[1,r-1]$所增加的贡献之和。那么维护的复杂度为$O(n\log n)$。

理解清楚上面的思路，以及式子的拆分，那么100pt的做法就明确了：对于固定右端点，区间最大值/最小值往左单调不减/不增。对于新加进来的点（这里以最大值为例），左区间所有比当前点值小的$Amax_{l,r}$都加一个增量x。那么单调栈去维护前缀区间最大值/区间最小值，然后对极差会加一个增量的统一区间修改一波。由于一个点至多被加进来/删除一次，而单次区间修改复杂度为$O(8\log n)$故总复杂度为$O(8n\log n)$。

### T161036 GSOR 1008

直接分治做。

假设两个子区间的答案已统计完，那么就剩区间覆盖左右两区间端点的子区间的答案贡献了。

（见[第一周模拟赛讲评](C:\Users\Administrator\Documents\Tencent Files\1019386658\FileRecv\模拟赛讲评.pptx)的图片）先$O(n)$分别计算绿、紫区间的区间最值x，后缀/前缀最值y。然后去考虑两个区间合并后左$x_1$/中间$y_1+y_2$/右$x_2$成为区间最大值时应满足的条件，此时就能转化成二维偏序问题，然后用排序+BIT解决。