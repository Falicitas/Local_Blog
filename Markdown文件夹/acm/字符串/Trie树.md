# Trie树

原来可以设计成一棵树、、以边为字母，构建树、、

## 01Trie树

可以将值按位将值分解放入Trie树中、、在Trie树上可以$O(32)$找到一个已存过的值、、在异或&贪心上是个不错的思考方向。

## 01Trie树维护异或和，全体加1

要实现全体加1的功能，故从低位向高位构造Trie、、

### 添加&删除

$w[p]$记录树上$p$节点被多少个数字所覆盖，$xor[p]$记录当前$p$的子树的异或之和。

将数$x$按低位向高位分解，将$x$分解完到节点$p$，$w[p]++$，然后从高位向低位回溯（$maintain$）$x$代表的节点，回溯路过的节点$w[p']++$。这样就实现了$x$对于每一位覆盖的$+1$贡献。对于异或和，由于下面的是高位，$xor[p] = xor[ch[p][0/1]] << 1 + [0 / 1] * (w[ch[p][0/1]] \& 1)$、、记得每次都清空，由子树更新。

关于$xor[p]\ \oplus = (xor[ch[p][0/1]] << 1) | ([0 / 1] * (w[ch[p][0/1]] \& 1))$的证明可以用数学归纳法：

粗糙一点、、假设子树的计算是正确的，子树向高位进$1$、、当$ch[p][1]$有被覆盖，且覆盖次数为奇数，则该位为$1$，，证毕。

还有并不是最高位为$0$就不更新了，用$MAXH$来限制更新深度，以保证能正常进位。

删除的操作本质同质，将每一位的覆盖贡献$-1$。

复杂度为$O(32)$。

### 全体+1

观察数$+1$后的变化：

> 1000(10)  + 1 = 1001(11) ;
>
> 10011(19) + 1 = 10100(20) ;
>
> 11111(31) + 1 = 100000(32) ;
>
> 10101(21) + 1 = 10110(22) ;
>
> 100000000111111(16447) + 1 = 100000001000000(16448) ;

即低位向高位的第一个$0$位改为$1$，低于该位所有$1$都为$0$。

具体在树上操作就是将子树交换，对于原来为$1$，现为$ch[p][0]$的子树来说，高位还需要修改，就一直迭代下去。

对于实际被更新的$0$节点，$ch[p][0],ch[p][1]$仍会$swap$一次，而当前节点为原来的最后一个$1$所指，由于一直会更新到$MAXH$，故$ch[p][0]$代表的前置$0$都有值，交换后相当于$0$变为$1$。

单次操作为$O(32)$。

### 合并Trie

~~待学习，在OI-wiki​上。~~ 感觉很简单，就直接写好了。

将树$B$合并到$A$。对于两棵Trie同位置的节点$a,b$：

> 若$a$是空节点，则直接返回节点$b$；
>
> 若$b$是空节点，则直接返回节点$a$；
>
> 若$a,b$均不空，合并信息，左节点为新左子树合并的返回的节点，右节点同理。

## 一些题目

### 820. 单词的压缩编码

将串反转，然后访问叶节点，，

顺便熟悉了leetcode的提交形式：数据在参数表里，函数返回答案、、其他外面的头文件什么的随便加，只要不要有主函数即可。

###  BZOJ1954 最长异或路径

两个节点上路径的异或和$F(u,v) = F(u,rt) \oplus F(v,rt)$，由于$F(lca,rt)$被异或了两次抵消掉了。。

可是枚举两个点的复杂度为$n^2$、、现将每个$F(v,rt)$的值按高位向低位加入01字符，然后枚举所有$F(v,rt)$，从高位往低位尽量找当前位与$F(v,rt)$的当前位不同的值。由贪心的思路，在高位能选与$F(v,rt)$不同的就必选，没有比这更好的方案、、没有当然就没得选啦。

### 【luogu-P6018】【Ynoi2010】Fusion tree

一棵树$x$的周围节点$+1$，选一节点$x$的权值$-v$，以及查询$x$周围节点的权值异或和、、

一般的套路就是构建有根树，对查询&修改，将父节点单独处理，由于就一个节点，操作是平凡复杂度$O(1),O(logn)$的。对于子节点则用相关的数据结构来维护。

对于每个点，对子节点构建01Trie树，维护子节点的异或和、、+1操作时在Trie树上全局+1，同时本节点放$lazy++$，表示周围节点被修改过、、由于父节点需要加1，故影响父节点的父节点维护的01Trie树、、每个节点的值$val[v] = A[v] + lazy[fa[v]]$，$A[]$代表$v$的值，$lazy[fa[]]$为父节点下放的$lazy$值。先在父父节点那删除$val$，更新$A[v]$，再重新添加。其余两个操作类似的原理。

### 【luogu-P6623】 【省选联考 2020 A 卷】 树

维护子树异或和、、由于每上升一个节点相当于所有权值+1，故一次dfs就可解决、、