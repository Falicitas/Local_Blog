# 线性基

一种可用来解决异或问题的 **数据结构** 。

大抵是希望构造一个集合，集合里的数仅通过异或操作可以还原原集合。从这个问题下手，就可以根据原集合，按位来构造一个线性基了。

## 插入与判定

线性基的第i位存储着以第i位为最高位的数字。

对于插入，要是当前数的最高位为i且当前的位置为空（a[i]=0），此时a[i] = 该数；否则该数 *异或a[i]* ，继续往下找。直至找到位置，或者这个数为0。

考虑这个过程，如果一个数走到了0，说明存在一种异或的数集合，使异或结果等于该数。对于没有走到0的，就存储着该数本身。所以对于一个集合这样操作，就实现了求得的线性基能能通过异或表示原数集的每个数。

```cpp
void ins(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i]){a[i]=x;return;}
            else x^=a[i];
    flag=true;
}
bool check(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i])return false;
            else x^=a[i];
    return true;
}
```

## 查询异或最值

对于最小值：由于线性基上存储的数可由原集合异或得到，故取线性基里的最小值。发现不管与其他的线性基里的元素异或都会增大其值，故最小值就是线性基里的最小值。 **如果原集合有两个数及以上相同的，那直接为0。** 

对于最大值：直接贪心。当前数的第i位要是为0，要是线性基第i位有值就异或，答案不会变差。

## 查询异或第k小

异或第k大反过来做。

考虑一种最简单的情况：当线性基的每一位均为$2^i$的形式，那么线性基就可以表示（假设有$[0,L]$的值）$2^{L+1}$个数的数。

遵循上面的方法，只要把原本的线性基简化一波，即对于值域内的每一位$i$，都只会在$a_i$中出现（即对于其他的$a_j$，第i位均为0）那么对于第i位到底能否决定值0/1，仅取决于线性基第i位有无值。

由于不能不选，对于0要特判一下。

结合上面的，一共有如下代码：

```cpp
int flag;//flag等于1，相当于可以选至少一个数异或使得异或结果为0
void ins(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i]){a[i]=x;return;}
            else x^=a[i];
    flag=true;
}
bool check(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i])return false;
            else x^=a[i];
    return true;
}
ll qmax(ll res=0){
    for(reg int i=MN;~i;i--)
        res=max(res,res^a[i]);
    return res;
}
ll qmin(){
    if(flag)return 0;
    for(reg int i=0;i<=MN;i++)
        if(a[i])return a[i];
}
ll query(ll k){
    reg ll res=0;reg int cnt=0;
    k-=flag;if(!k)return 0;
    for(reg int i=0;i<=MN;i++){//预处理
        for(int j=i-1;~j;j--)
            if(a[i]&(1ll<<j))a[i]^=a[j];
        if(a[i])tmp[cnt++]=a[i];
    }
    if(k>=(1ll<<cnt))return -1;
    for(reg int i=0;i<cnt;i++)
        if(k&(1ll<<i))res^=tmp[i];
    return res;
}
```

