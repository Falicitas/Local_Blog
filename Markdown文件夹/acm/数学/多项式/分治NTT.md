# 分治NTT

暂时不知道是否只用来求$f_i = \sum\limits_{k=1}f_{i-k}g_k$的、、

对于给定的$g,f_0 = a_0$，$f$由方程$f_i = \sum\limits_{k=1}f_{i-k}g_k$生成，求$f$。

## 分治NTT

用的是cdq分治，每次将已完成转移的左区间与$g$从$g_0$开始长度为$r-l+1$的多项式做卷积贡献给右区间。

emm由于没有单独写过cdq分治的文，其实$cdq$分治主要利用了**块**的思路，将单独的元素贡献划分成**整块**的贡献，从而降低复杂度。

## 生成函数

令$F(x) = \sum f_i x^i,G(x) = \sum g_i x^i$，

卷积一下，$F(x)G(x) = \sum x^i\sum f_kg_{i-k} = F(x) - f_0$

$F(x) = \frac{f_0}{1-G(x)}(\bmod x^n)$

求逆一下即可。

生成函数大法好！

## 一些习题

### CF553E Kyoya and Train

这道题我不是用分治FFT做的。。

初始想到$dp(u,i)$表示花$i$时间走到$u$的最小费用，然鹅$dp(1,i),i>0$初始化为？不清楚，将“恰好花$i$时间”改为“至少花$i$时间”又不好转移，此时将状态反过来：

$dp(u,i)$为到了$u$处花了$i$时间，到$n$还需花的最小费用。此时初始状态就很明确：$dp(n,i) = 0,i\leq t$。然后反向建图，$dp(u,j) = min\{c_i + \sum_{k=1}^{t}dp(v,j+k) * prob_i(k)\},edge_i = <u,v>$，用已知状态（这里的状态为一个**多项式**）去更新其他状态，最终结果自然为$dp(1,0)$。

对于$dp$式还需要把$prob$反转后再能做卷积。对于图上的状态的更新，很明显**多项式**是没有类似于距离的考量尺度的，即不能通过比较两个多项式来表示哪个可以用来更新其他多项式（故dijkstra不能使用）。故使用`SPFA`，当一个式子卷积后，只要被更新的状态对应的多项式存在一个项能被更新，即被 **松弛** 了，此时就可以将其当做可以更新其他点的状态。故`SPFA`不需要考量尺度，只要当前状态被**松弛**了，当前状态就需要为松弛其他状态做**预备**。关于`SPFA`最坏复杂度是$O(nm)$，没有被卡的话期望也比较低，总之在这道题能过，复杂度为$O(nmklogk)$。

另外还想说：若是以将图按时间来分层，可以发现一个点是不能转移给祖先点的，也证明了dp方程的正确性。

貌似能理解了233

由于预处理了边界情况$f_{*,t+k},f_{n,*}$的情况，然后考虑对时间进行分治：

假设$k\in[mid,r]$的$f_{u,k}$均已知，对于每条边$<u,v>$来说，可以将$f_{v,k},k\geq mid$的状态转移给$f_{u,k'},k'\in[l,mid-1]$，然后处理一下多项式乘法的细节即可。即这里由较多时间的状态来保证求解的DAG性（虽然我也不知道在说什么233