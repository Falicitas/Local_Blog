# 最大公约数

## 递推公式

$(a,b) = (b,a\%b)$

证明：设$a>b$，则$a = b*k + c$。

先证$(a,b) \Rightarrow (b,a\%b):$设$d|a,d|b$，即$d$来自$a,b$的公约数集。$a = b*k + c\Rightarrow \frac{c}{d} = \frac{a}{d} - \frac{b}{d}*k$。右式结果为整数，可推出$d|c\Rightarrow d|(a\%b)$。

再证$(b,a\%b)\Rightarrow (a,b) :$设$d|(a\%b),d|b$，即$d$来自$(a\%b),b$的公约数集。$a = b*k + c\Rightarrow \frac{a}{d} = \frac{a\%b}{d} + \frac{b}{d}*k$。右式结果为整数，可推出$d|a$。

可以看出来自两个集合的公约数都能推出在对方集合中，则两集合相同，最大公约数自然相同。

由此性质还能推得$a^b \equiv (a\%p)^b(\%p),$底数与$p$的公约数不变、、$(a,p)=(a\%p,p)$

### 跟斐波那契的关系

对斐波那契的相邻两项做gcd递推，能获得最坏算法，由于每次得出的答案都是前一个相邻两项的gcd答案。

## 最小公倍数

好无聊的证明233

对于$a,b$进行质因数分解有$a=p_1^{k_1}*p_2^{k_2}*...*p_s^{k_s},a=p_1^{r_1}*p_2^{r_2}*...*p_s^{r_s}$

最大公约数$(a,b) = p_1^{min(k_1,r_1)}*p_2^{min(k_2,r_2)}*...*p_s^{min(k_s,r_s)}$

最小公倍数$[a,b] =  p_1^{max(k_1,r_1)}*p_2^{max(k_2,r_2)}*...*p_s^{max(k_s,r_s)}$

有$(x+y) = max(x,y) + min(x,y)$
推出$a*b = gcd(x,y) * lcm(x,y)\Rightarrow lcm(x,y) = \frac{a*b}{gcd(x,y)}$

## 扩展欧几里得

求$ax + by = gcd(a,b)$的一组解。

### 证明
设
$\begin{array}{l}
a x_{1}+b y_{1}=\operatorname{gcd}(a, b) \\
b x_{2}+(a \bmod b) y_{2}=\operatorname{gcd}(b, a \bmod b)
\end{array}$
由欧几里得定理可知： $\operatorname{gcd}(a, b)=\operatorname{gcd}(b, a \bmod b)$

所以  $a x_{1}+b y_{1}=b x_{2}+(a \bmod b) y_{2}$

又因为 $a \bmod b=a-\left(\left\lfloor\frac{a}{b}\right\rfloor \times b\right)$

所以

$\begin{array}{l}
  a x_{1}+b y_{1}=b x_{2}+\left(a-\left(\left\lfloor\frac{a}{b}\right\rfloor \times b\right)\right) y_{2} \\
a x_{1}+b y_{1}=a y_{2}+b x_{2}-\left\lfloor\frac{a}{b}\right\rfloor \times b y_{2}=a y_{2}+b\left(x_{2}-\left\lfloor\frac{a}{b}\right\rfloor y_{2}\right)
\end{array}$
因为 $a=a, b=b,$ 所以 $x_{1}=y_{2}, y_{1}=x_{2}-\left\lfloor\frac{a}{b}\right\rfloor y_{2}$
将 $x_{2}, y_{2}$ 不断代入递归求解直至 GCD（最大公约数, 下同）为 0 递归 $x=1, y=0$ 回去求解。

间接证明裴蜀定理是正确的、、

### 性质

由扩欧原理，解$ax+by=c$时，需看是否满足$d|c$，不满足则无整数解。

当满足$d|c$，由$ax+by=g,g=gcd(a,b)$求出的扩欧的一组解$x',y',g$。由公式$ax+by=c\Rightarrow a*\frac{g*x}{c} + b*\frac{g*y}{c}=g$，故$ax+by=c$的一个特解为$x = \frac{c*x'}{g},y = \frac{c*y'}{g}$。当$x$增加$k*\frac{b}{g}(x最小增加单位\frac{b}{g})$,$y$减少$k*\frac{a}{g}(y最小减少单位\frac{a}{g})$，等式仍成立。

故$ax+by=c$的通解为$x = \frac{c*x'}{g} + k*\frac{b}{g},y = \frac{c*y'}{g} - k*\frac{a}{g}$。

### 求一系列特解

将原式变换一下$ax + by = c\Rightarrow y = \frac{c}{b} - ax$，即转化为平面上的直线。根据$k = -a,b = \frac{c}{b}$进行分析。

## 一些习题

### P2152 [SDOI2009]SuperGCD

高精求$a,b$的gcd、、

py代码：

```cpp
import fractions
print(fractions.gcd(int(input()),int(input())))
```

效率很高、、

### P1414 又是毕业季II

最大公约数 = {约数集合}、、故求n个数的约数，当前选$k$个数时，只要相同的约数个数$cnt_j>=k$，就可以选约数$j$、、故在$j$中取最大的那个即可。

### P2613 【模板】有理数取余

求逆元$x,ax\equiv 1(\%p)$，$a$是高精度，则对$a$先取模再求逆元、、

然后就A了。

### 2020牛客高校第三场F Fraction Construction Problem

给定$a,b\leq 2e6$,构造$\frac{c}{f} - \frac{e}{d} = \frac{a}{b}$。

### 2020牛客多校第七场B Mask Allocation

给$m * n$个口罩，分成若干不能再拆分的组，重新组合后能组成$n$组$m$个与$m$组$n$个，按降序排序字典序最大。

做法是令$n<m$，则构建$\frac{m}{n}*n$个$n$，方案转为$m\%n,n$。

先证可行性：首先已经有$\frac{m}{n}*n$个$n$了，$(m\%n,n)$必能产生一系列小于$n$的数且其能组合成$n$，而$n$组每组还差$m\%n$个数，其也能满足垒在一起有$n$组$m$个。

再验正确性：从贪心的角度出发，假设能多放一个$n$,比如$(10,13)$，放$11$个$10$，剩下的$20$绝不够填补所有的$10$到$13$,而$10$个$10$恰好每个$10$放由$(3,10)$产生的数就能满足题目要求。

### P2421 [NOI2002]荒岛野人

岛内保持和平意味着任意两个人在寿命取min内不会相遇。那么就容易列出方程：$C_i+kP_i \equiv C_j + kP_j(\bmod M)\Rightarrow k(P_i-P_j) + qM= C_j-C_i$，解出最小非负解$k>min(L_i,L_j)$或者无解时不会相遇。那么复杂度为$O(n^2M\log C )$（实际很快求出解来）。

这里有个技巧，要求的是k的最小非负解，不关注q，那么可以将方程中的$(P_i-P_j),(C_j-C_i)$模M成非负数然后在进行exgcd，此时不影响k的最小非负解（而q的解则会因为取模的问题线性位移若干位）。

### P4296 [AHOI2007]密码箱

解出$x^2\equiv 1(\bmod n),x\leq n$的所有x。

变式，得$(x-1)(x+1) = kn$，意味着$n|(x-1)(x+1)$。令$n=a*b$，即$x-1 = ka \and x+1 = kb$，或者$x+1 = ka \and x-1 = kb$。枚举$n$的所有因子，复杂度为$O(\text{因子个数}*\sqrt{n})$（实际比这个小得多）。

可能会有疑问，$n|(x-1)(x+1)$为何能推出$a|(x-1)\and b|(x+1)$这样的形式。

反证法：假设不能推出上面形式。

当$x=2$，即右侧的一项$(x-1)=1$，此时可以推出$n|(x+1)$，与假设矛盾。

反之，$(x-1),(x+1)$均为非1数，也意味着假设不能推出单独整除的n为合数，那就意味着n可以分解成整除(x-1)的a和另外一个b，迭代下去证明即可得正解解出的x的范围必包括$n|(x-1)(x+1)$的所有x。