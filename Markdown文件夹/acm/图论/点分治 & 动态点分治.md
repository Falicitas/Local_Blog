# 点分治 & 动态点分治

## 性质

一类将问题分治解决的算法。

一般的流程都是：

> * 找重心。
> * 依次遍历每个子树：先统计答案。当某点与维护的状态集满足互补关系（即符合条件）就更新答案。当遍历完一次子树后，将子树的状态添加到状态集中。
> * 遍历子树删除状态集。
> * 递归子树。

## 动态点分治

### 关于点分树

点分治先从第一个(层)重心开始计算，分治该重心的子树所确定的第二层重心，直到重心代表的树大小为1。倘若按照点分树的构造方式来看，当某个点发生改变，影响（由点分治思想）答案统计的重心为当前第i层，第i-1层，...，第1层的重心。比如修改的点为第一层重心，则只影响自己的答案统计。而第5层重心被修改的时候，则会影响第5层，第4层，...，第1层的重心的答案统计。而由于点分树的高度不超过logn，而一般维护的数据结构的修改操作能做到$O(1) or O(logn)$，所以可以直接**在点分树上从修改的点一直往上更新到第一层节点(重心)**，单次修改复杂度为$O(logn) or O(log^2n)$

### [bzoj3730]震波

基于点分树的思路，考虑一个点修改后，需要对祖先点做何种修改。由于需要查询离自己不超过距离k的决策集，故考虑用线段树（或BIT）维护每一个重心的决策，每次有点更新，就将该点在点分树上的祖先点（包括自己）以该点距祖先点的距离为下标修改对应的美观值（注意，由于之前的美观值为$val'$，所以增加的美观值应为$\Delta v= val-val'$）。然而一条合法的路径不能来自同一个子树的两个路径之和，故需要在被更新的每个节点处，记录上一层到被更新的点的信息（也就是每个点多开一个BIT），在容斥时每次减去新的BIT中维护的点即可。距离尺度（也就是据上一层节点的位置关系）等同当前所求的方案的尺度，故查询的范围是一样的。

### [bzoj1095][ZJOI2007]Hide 捉迷藏

由于要找最长的路径，故维护的是某个重心的最长以及次长的路径和（同时最长和次长不能来自同一个子树）。首先维护一个可删堆t[]，t[u]存放以u为根节点的子树的全部长度方案。再尝试用另外一个堆s维护来自一颗子树的一个最大值。由于s只维护每个子树的最大值，所以s中的每个路径长都来自不同的子树，故s的最大与次大构成以u点为重心的最大方案。
怎么更新s呢？对于更新点u来说，该点如果变暗，对于该点来说就增加了长度为0的一个方案。对于每个祖先节点v来说，就多了一个从更新点到上一层节点f距离为dis的方案，放入到t[v]中。由于s[f]维护t[v]的最大值，当t[v]发生变动时，需要从s[f]里删除来自v子树的方案，当t[v]更新完后，再由t[v]的最大值来加入到s[f]中，这样就保证s[f]维护的是自己某一颗子树的一个最大值。
同时得再维护一个堆ans。更新时若s[f]发生变动，ans也会发生变化。故在s[f]更新之前，先把s[f]存到ans的答案删除，待s[f]更新完后再将s[f]的最大与次大值的和来更新ans。这样整棵树的最大值就是ans的顶部。

### P5538 【XR-3】Namid[A]me

用点分治和哈希加速~~水了一个~~AC（逃

用点分治降低树上方案统计复杂度，将决策点加入到hash中，然后分治计算方案、、当时码的时候，极度害怕过多决策点，复杂度趋于$O(n^2)$，不过由于与操作，单个子树最多产生$O(|S|*30)$的决策点，其中$|S|$是现有决策集的秩、、虽然还是数量巨大。。

计算$x^x(\%p)$时可用原根加速取模（参考了标答的做法，原本用快速幂TLE了。。）根据原根性质，x可以被原根表示$x\equiv g^k(\%p),x^x \equiv (g^k)^{g^k} \equiv g^{kg^k}(\%p)$,取以$g$为底的离散对数，

$Indx \equiv k$,故$x^x \equiv g^{x*Indx}(\%\varphi(p))$

故$x^x\equiv x*Indx$,预处理对数和g的幂，介样子就可以就可以$O(1)$求了qwq
