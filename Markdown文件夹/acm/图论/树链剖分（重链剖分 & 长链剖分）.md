# 树链剖分（重链剖分 & 长链剖分）

是一种将树剖分成若干条重链的算法，每个节点仅属于一条重链，且重链在线性数据结构的储存上有特殊的性质。

## 定义

跟启发式合并一样，处理的是有根树，对于$u$的子节点$v$分两种情况：

> 1. 没有子节点，此时没有重边（必定没有轻边）
> 2. 有子节点，子树最大的子节点$bson$与$u$的边记为**重边**，其余的子节点与$u$的边为**轻边**

优先遍历重边，则重边相连的节点构成一条**重链**，此时树被划分成若干条重链。

<img src="C:\Users\Administrator\Desktop\markdown图片\重链剖分1.png" alt="重链剖分1" style="zoom:40%;" />

## 具体实现

那么分两次`dfs`:

`dfs1`：记录$bson[],siz[],dep[],fa[]$，分别存储$u$的重儿子编号，以$u$为根的树大小，$u$的深度，$u$的父亲。

`dfs2`：记录$top[],dfn[],rnk[]$，分别储存$u$节点所处重链中深度最小的节点，节点$u$在`dfs`序中的编号（即在线段树下维护的下标），以及`dfs`序上编号对应的节点。

## 性质

> 1. **树上每个节点都属于且仅属于一条重链**
> 2. 所有的重链将整棵树 **完全剖分**
> 3. 在剖分时 **优先遍历重儿子** ，最后重链的`dfs`序就会是连续的。
> 4. **一颗子树内的 DFN 序是连续的**
> 5. 可以发现，当我们向下经过一条 **轻边** 时, 所在子树的大小至少会除以二。因此, 对于树上的任意一条路径, 把它拆分成从 $lca$ 分别向两边往下走, 分别最多走 $O(\log n)$ 次，因此, 树上的每条路径都可以被拆分成不超过 $O(\log n)$ 条重链。（简单理解即是往轻边走至多走logn层，那么路径则被logn个重链所划分）

## 应用

### 跳链

对于路径$<u,v>$，假设$u,v$中$u$所在链顶节点$u.top$是深度较大的一个（也说明$u,v$不在同条链上），则对$<u,u.top(或u.top.fa)>$（同一条链的DFN序是挨在一起的）进行相应操作，然后**$u$跳到$u.top.fa$**上；直到$u,v$在同一条链上。

跳链操作适用于维护链上路径的操作，以及求`lca`：深度大的不断往上跳，直至同一条重链，深度低的即为`lca`。

### 设置bottom

设置一个$u$为根节点的树的范围$bottom[u]$，易知其为子树$dfs$完后的`dfs`序cnt、、可以用作子树的操作、、

## 如何卡树剖（重链）

一般情况下树剖的 $O(\log n)$ 常数不满很难卡, 如果要卡只能建立二叉树。
我们建立一颗 $\sqrt{n}$ 个节点的完全二叉树。对于每个节点到其儿子的边，我们将其替换成一条长度为 $\sqrt{n}$ 的链（为了卡够线段树的logn）。
这样子我们可以将随机询问将跳链次数上到平均 $\frac{\log n}{2}$ 次，同时有 $O(\sqrt{n} \log n)$ 的深度。
加上若干随机叶子看上去可以卡树剖。但是树剖常数小有可能卡不掉。

## 长链剖分

将**重儿子**定义为深度最深的子树的节点，具体求法跟重链剖分一样。

由于长链剖分的构造方式，跳链的次数为$O(\sqrt{n})$次、、

### 应用

长链剖分可用来线性解决维护子树中只跟深度有关的信息，比如以某点$u$为根节点的树，求出该树哪个深度的节点最多。

算法基于以节点$u$为根节点的深度信息均由子树维护的深度信息+1而来，对重链通过移动指针实现$O(1)$**转移**，再通过对轻儿子的暴力合并来实现深度信息的合并。由于实际每条重链只会被合并一次，重链对于树构成了划分，故复杂度仅为$O(n)$。

具体的算法流程：

定义$*f[]$指针数组，用于表示节点$u$对应深度$0,1,2,...$的节点数$f[u][0],f[u][1],f[u][2],...$。用$tmp[]$来**实际存储**深度的信息。由于$f[]$的指针得指向实际空间才能进行操作，于是巧妙的分配$tmp[]$空间独立**储存每条重链的深度信息**,让$f[]$可以实现$O(1)$的**转移**。

1. 记当前操作的树根节点为$u$,重链长为$len[u]$，$len[u]$包括$u$本身，即叶节点的$len[v]=1$。$tmp[]$还可用空间$*id$（$id-1,id-2...$的空间已用完）。

2. 在操作前先给$u$的重链在$tmp[]$上分配$len[u]$的连续区间供$u$的重链储存。将重儿子的**地址**设置成$u$的**深度为1开始的地址**，接着先遍历重儿子。遍历好的重儿子已完成重儿子代表的子树的所有深度信息合并，此时也意味着重儿子的深度信息已$O(1)$转移给$u$节点了。

3. 之后分别给$u$的每个轻儿子（每个轻儿子分别对应独立的其余**重链**）开$len[v]$的空间供$v$的重链存储深度信息，遍历完轻节点后暴力与$u$合并。
4. 最后关于$u$为根节点的树的深度信息就统计完毕了。

关于复杂度为线性的图示：

<img src="C:\Users\Administrator\Desktop\markdown图片\长链剖分1.png" alt="长链剖分1" style="zoom:50%;" />

可以发现，每个块最多被暴力合并1次（块内是没有合并操作的，只有块间），其余的均是$O(1)$转移。

## 如何卡树剖（长链）

构造二叉树：设构造当前节点的参数为$D$.

左子树构造$D-1$的二叉树；右子树构造$2D-1$的链、、画图可知每条链约$O(D)$长，共$D$条链。

画图易知，节点个数$T(D) = 2D + 2D - 2 + ... = O(D^2)$

故可以$D = \sqrt{n}$。

## 一些习题

### P2590 [ZJOI2008]树的统计

树剖裸题。

### #6669. Nauuo and Binary Tree

蛮好的一道应用树剖的交互题。一个以$1$为根节点的二叉树，仅提供任意两点间的距离，要求构造出二叉树来，点$n<=3000,q$不得超过$30000$。

首先~~应该考虑到按照深度进行添点~~，询问$2\sim 3000$到$1$的距离，先添深度小的点，后来填的点的直接父节点必定已在树上。但是暴力询问任意两点间距离为$1$的询问次数是$O(n^2)$的QAQ

去考虑树剖中用到的重链结构，对于想要查询的点$u$来说，必定在重链上一个节点$v$的子树中；设法让这个点$v$成为$u$和某个节点$z$的$lca$，以方便找到$v$。不妨令$z = bot[tp]$，$tp$是当前重链的头结点，而$bot[tp]$为当前重链的尾节点。去查询链$d = dist<u,w>,$可以发现$d = dep[u] + dep[bot[tp]] - 2d[v]\Rightarrow d[v] = \frac{dep[u] + dep[bot[tp]] - d}{2}$，再根据重链在$dfn$序上连续得到$v$的节点编号。由于$u$在$v$的轻子树上，当$v$有一个子节点为空时，$u$就是$v$的父节点，否则递归重链解决问题。

思来想去，要是是三叉树或普通树，也能利用树剖的性质求得$u$所在的子树的根节点$v$，但似乎并不能确定$u$在$v$的哪颗轻子树上，感觉还是要单次询问$O(n)$次233不过根据深度来建树，以及利用lca来确定$u$在什么点的子树上还是值得学习的。

### CF1009F Dominant Indices

长链剖分裸题，具体的流程跟上面讲的深度信息合并一样。

###  POJ - 3237 Tree

树剖裸题。边放点上；单点修改直接修改到叶节点；区间取反，同时维护max，min，取反时max，min倒转。

然鹅调了一下午没调出来QAQ

### P3979 遥远的国度

树链剖分。Trick：对于换根操作，不实际去换根，而是在查询 or 修改操作时根据原根与当前根的位置关系来确定修改对应的部分。

将`dfn`序列出来，可以发现查询的子树$x$不在以原根为有根树的当前根的 **祖先** 时，查询的子树与原子树相同。反之，可以发现其实际查询的是以原根为有根树的子树$x$的一个子树的补集，补集在$dfn$序上为两个连续的区间，故查询补集即可。

### P3313 [SDOI2014]旅行

树剖+动态开点线段树。

基本思路：对于每一个宗教开一个线段树，对于一种宗教来说每次只在链上找对应线段树的对应区间。对于1e5个宗教来说，开长度为1e5的线段树显然不可能，此时利用主席树的思想**动态开点**，版本$T[i]$对应最新的宗教$i$在树剖区间的分布，修改单点时向左或向右加入新子节点，然后向上维护最大值 & 总和。复杂度为$O(nlog^2n)$

### [SDOI2015]寻宝游戏

包含所有打标记的最小连通块的路径和。

用一个set来维护有序的dfn序，然后前后减。