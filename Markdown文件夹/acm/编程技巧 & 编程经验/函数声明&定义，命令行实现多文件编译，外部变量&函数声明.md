# 函数声明/定义，命令行实现多文件编译，外部变量/函数声明

## 函数声明/定义

据群友的讨论与实际的操作结果，有以下结论：

编译和链接是分开的，而在编译过程，对于函数只需要 **声明** 即可。即哪怕一个函数没实现，只要有声明正确，程序就可以通过编译形成.o文件。而在链接阶段会出错。（实测正确）

那么可以这么理解：链接时会将函数扔进一个 “库” 里。只要编译前源程序调用某个函数func前都有 **声明** func，那么程序就是可 **编译** 的，在 **链接** 时就会在 “库” 里去找这个函数。

## 命令行实现多文件编译

### 单源文件编译、o文件

在从源文件cpp到exe，实际上中间还形成了一个.o文件。即下面的过程：

`.cpp-->.o-->.exe`

文件名分别为

`源文件`-->`中间目标文件`-->`可执行文件`

第一个过程叫 **编译** ，形成.o文件，第二个过程叫 **链接** ，形成.exe。

编译一个cpp文件，可以在打开文件目录下的git hash（命令行），输入`g++ -std=c++17 filename.cpp -o txt.exe`，这时会生成txt.exe。

> `-std=c++17`是语言版本参数。
>
> `-o file_name` 把生成的默认与源文件同名的文件名换成指定名file_name。
>
> `-g -Wall` 打印编译/链接log。
>
> `-c`仅生成.o中间目标文件。

如何多文件生成一份exe呢？

举例：

```cpp
#include<bits/stdc++.h>
#include"qwq.h"
using namespace std;

int main()
{
    cc();//qwq.h里的函数
    return 0;
}//main.cpp
```

```cpp
void cc();//qwq.h
```

```cpp
#include<cstdio>

void cc()
{
    printf("QwQ");
}//qwq.cpp
```

共三个文件main.cpp,qwq.h,qwq.cpp。

执行`g++ std=c++17 main.cpp qwq.cpp -g -Wall -o txt `，即可生成txt.exe文件。

发现没头文件什么事。实际上，对于源文件加入了头文件后，相当于头文件里的函数都已经声明好了，可以直接使用了。而函数实现则放在（一般同名的cpp文件）另一源文件里。（实测同名源文件甚至不需要使用同名头文件，不过根据编译/链接的逻辑，讲得通）

## 外部变量 / 函数声明

用到了修饰语`extern`。

简单来说，extern 用于修饰的变量或函数，代表变量/函数可能在其他源文件/头文件的全局变量里已经声明过了。在写程序的时候就可以直接使用变量/函数而不怕 **文件间各自编译后链接** 发生冲突。

加个extern "C"，则是可以兼容C文件。

用extern声明变量不能直接进行初始化，即`extern int x = 0\\error`，但可以声明后，进行正常的赋值与修改操作。