# 各版块总结——简易版

遵循 **大道至简原则** 来编写。能精简则精简，且避免二次阅读产生误解。

各版块都能写到这里。最后按需导出。

> 大道至简原则：仅记录 易踩坑 & 结论 & 需记住的证明 & 具体做法 & 切入角度 & 做题经验。 **若是过于熟练，则直接删除。** 

新加了个 *切入角度（思路）* ：从问题解决模型上来看，切入角度类似于作为把问题引入到问题解决模型里的指针。也是解决问题重要的一环。故也需遵循大道至简原则。典型的例子如dp。

## $\LaTeX$

`\genfrac #1 #2 #3 #4 #5 #6`

#代表参数。参数1,2分别对应左右框。3,4分别代表中间横线粗度，整体大小。数字越小，粗度越小（0为没有粗度），整体大小越大（0为最大）。5,6分别对应上下指标。

比如：

$\genfrac<>{0}{0}{2}{3},\genfrac[]{1}{1}{2}{3}$

## UB 以及易犯小错误以及语法问题

- `1e18 + 13 != 1000000000000000031LL`，所以给变量赋值LL类型，直接手打0。

- **STL set，map非自定义类的重载** ：比如int，double等已实现类的重载。

  声明

  ```cpp
  struct cmp{
      bool operator()(const int &a, const int &b)const {return dfn[a] < dfn[b];}
  };//以树上dfn序排序举例
  
  set<int,cmp> s;
  ```

- 强调符号：「」

## 基本思想

- **间接法与分类讨论** ：基本上所有题都可以结合两种思路来解决~~（只要拆的够细）~~，写题时注意运用两种思路。

## 动态规划

- **从添加物品角度开始dp** ：常见的有背包dp。每次仅考虑加入一个物品的状态变化。
- **最优分析——由二生万物** ：在考虑复杂的n个元素构成的收益/代价时，从一对元素的所有可能关系进行讨论。如n个物品可任意划分为k堆，每一堆的代价由堆的物品个数决定。那么考虑第一堆x，第二堆y，假设代价为x^2+y^2。可发现有三种关系 $x-y\leq 1,y-x>1,x-y>1$ ，假设发现两个堆的个数均摊最优，可推至全体均摊最优。
- **线段树合并——单件物品修改** ：物品两两合并（即把物品看做泛化物品，i->f(i)，可以两两合并），在线段树上维护。
- **闵科夫斯基和合并凸壳** ：对于dp优化中，可能会涉及凸壳的合并。根据闵科夫斯基和的合并复杂度为 $O(n+m)$ ，其中 n,m 分别为两个凸壳的点的个数，可以将凸壳合并，进而优化dp的复杂度。

## 数学

- **光速乘** ：

  ```cpp
  inline ll mul(ll a,ll b,ll mod)
  {
      ll tmp = ((a*b-(ll)((long double)a*b/mod)*mod+mod)%mod);
      return tmp<0?tmp+mod:tmp;
  }
  ```

  ICPC可以使用 `__int128` ，但比光速乘慢3~4倍。

- **累乘计数** ：可以将函数值f(x)的累乘形式，转化成 f(x)=y 的 y 出现次数 cnt_y 的累加形式。

- **逆序对计数** ：对于一对物品，若有前后关系，可考虑转成逆序对关系。由于一段连续的逆序对块内部的元素顺序对于外部来说没有影响，通常采用 **合并** 的操作将连续元素视作整体，来来进行dp或贪心。

- **取整** ： $a * b \leq c \Leftrightarrow b \leq \lfloor c / b \rfloor$ ， $a * b \geq c \Leftrightarrow b \geq \lceil c / b \rceil$ ， $a * b > c \Leftrightarrow a > \lfloor c / b \rfloor$ ， $a * b < c \Leftrightarrow a < \lceil c / b \rceil$ 。

- **不等式转化** ：

  > $\lfloor\frac{n}{p+1}\rfloor \leq q,\lfloor\frac{n}{p+1}\rfloor \leq p \Leftrightarrow n+1\leq (p+1)(q+1)$ 
  >
  > 先证明充分性：
  >
  > $\lfloor\frac{n}{p+1}\rfloor = \lceil\frac{n-p}{p+1}\rceil \leq q$ ，放缩
  >
  > $\frac{n-p}{p+1} \leq q \Rightarrow n - p \leq qp + q \Rightarrow n +1\leq qp + q + p + 1 = (p+1)(q+1)$
  >
  > 证必要性：
  >
  > $n+1 \leq (p+1)(q+1) \Rightarrow n < (p+1)(q+1)$ ，除过去
  >
  > $\lfloor\frac{n}{p+1}\rfloor < q+1 \Rightarrow \lfloor\frac{n}{p+1}\rfloor \leq q$ 。

### 多项式

- **牛顿迭代** $G(F(x)) \equiv 0(\bmod x^n)$ ： 假设已求得 $f_0(x)$ ，即 $f(x)$ 在模 $x^\frac{n}{2}$ 意义下的函数，对 $G(f(x))$ 进行关于 $f(x)$ 在 $f_0(x)$ 处的泰勒展开，有 $\sum\limits_{i=0}^\infty \frac{G^{(i)}(f_0(x))}{i!}(f(x)-f_0(x))^i = 0$ 。对于 $(f(x)-f_0(x))^i = 0,i\geq 2$ ，得 $G(f(x)) = G(f_0(x)) + \frac{G'(f_0(x))}{1}(f(x) - f_0(x)) \equiv 0 (\bmod x^n)$，得$f(x) \equiv f_0(x) - \frac{G(f_0(x))}{G'(f_0(x))}(\bmod x^n)$ 。通过构造 $G(x)$ ，来递归求 $f(x)$ 。以下 $h$ 均为原函数。

  > 多项式取逆：
  >
  > $g(f(x))=\frac{1}{f(x)}-h(x) \equiv 0 \quad\left(\bmod x^{n}\right)$
  >
  > $\Rightarrow f(x) \equiv f_{0}(x)-\frac{\frac{1}{f_{0}(x)}-h(x)}{-\frac{1}{f_{0}^{2}(x)}}\quad\left(\bmod x^{n}\right)$
  >
  > $f(x) \equiv 2 f_{0}(x)-f_{0}^{2}(x) h(x)\quad\left(\bmod x^{n}\right)$

  > 多项式开方：
  >
  > $g(f(x))=f^{2}(x)-h(x) \equiv 0 \quad\left(\bmod x^{n}\right)$
  >
  > $\Rightarrow f(x) \equiv f_{0}(x)-\frac{f_{0}^{2}(x)-h(x)}{2 f_{0}(x)}\quad\left(\bmod x^{n}\right)$
  >
  > $\equiv \frac{f_{0}^{2}(x)+h(x)}{2 f_{0}(x)} \quad\left(\bmod x^{n}\right)$

  > 多项式Exp：
  >
  > $g(f(x))=\ln f(x)-h(x) \quad\left(\bmod x^{n}\right)$
  >
  > $f(x) \equiv f_{0}(x)-\frac{\ln f_{0}(x)-h(x)}{\frac{1}{f_{0}(x)}}\quad\left(\bmod x^{n}\right)$
  > $\equiv f_{0}(x)\left(1-\ln f_{0}(x)+h(x)\right) \quad\left(\bmod x^{n}\right)$

  > 另附多项式ln（虽然不用牛顿迭代求）：
  >
  > 求导再积分。
  >
  > $\begin{aligned}
  >  \frac{\mathrm{d} \ln{f(x)}}{\mathrm{d} x} & \equiv \frac{f'(x)}{f(x)} & \pmod{x^{n}} \\
  >  \ln{f(x)} & \equiv \int \mathrm{d} \ln{x} \equiv \int\frac{f'(x)}{f(x)} \mathrm{d} x & \pmod{x^{n}}
  > \end{aligned}$


- **多项式k次方** ： 利用 $f^k(x) = \exp(k\ln f(x))$ 求解。复杂度 $O(n\log n)$ 。常数项不为1时：左移多项式至常数项非0。多项式每项同除常数项，以保证做运算的多项式常数项为1。记从左到右第$j$项第一个非零。 $f^k(x) = (x^jf_j\frac{f(x)}{f_jx^j})^k = f_j^k * x^{k*j}*(\frac{f(x)}{f_jx^j})^k = f_j^k * x^{kj}*\exp(k\ln(\frac{f(x)}{f_jx^j}))$

- **拉格朗日插值** ： $f(x) = \sum y_i \prod\limits_{i\neq j} \frac{x - x_j}{x_i-x_j}$ 。

- 常用公式 & 套路：

  > $\sum\limits_{i=0}^n g_i$
  >
  > 有时候需要反复求某函数的前缀和。到时候拿月赛题目举例。
  >
  > 令$G(x) = \sum g_ix^i$，则直接$F(x) = G(x) * \frac{1}{1-x}$，那么$\sum\limits_{i=0}^n g_i = [x^n]F(x)$。

  > $\sum\limits_{i=1}^n \frac{1}{1-a_ix}$
  >
  > 令 $H(x) = \sum\limits_{i=1}^n\frac{1}{1-a_ix} = \sum\limits_{k=0}\sum\limits_{i=1}^na_i^kx^k$ 。
  >
  > 发现$\ln'(\frac{1}{1-ax}) = \frac{a}{1-ax} = a\sum (ax)^i$
  >
  > 则构造函数$G(x) = \sum\limits_{i=1}^n a_i\sum\limits_{j=0}(a_ix)^j$，则可以通过$H(x) = xG(x)+n$求得$H$。
  >
  > $G(x) = \sum\limits_{i=1}^n \ln'(\frac{1}{1-a_ix}) = (\sum\limits_{i=1}^n \ln(\frac{1}{1-a_ix}))' = ( \ln(\prod\limits_{i=1}^n\frac{1}{1-a_ix}))'$。
  >
  > 令$T(x) = \prod\limits_{i=1}^n\frac{1}{1-a_ix} = \frac{1}{\prod\limits_{i=1}^n1-a_ix}$，其分母可以分治NTT求。
  >
  > 结果为$H(x) = x\ln(T(x))' + n$。

  > 累乘形式与累加形式转换
  >
  > $\prod f_i(x) = \exp(\sum \ln(f_i(x)))$。这个是很基本的变换操作了。常见推理方式。

  > k次多项式由连续的k+1个点确定（k+1个点已确定，简记为点1,2,...,K，K=k+1），单求一个点的函数值。
  >
  > 可以 $O(n)$ 求解。具体的，设求解点为n，利用拉格朗日插值表示法， $f(n) = \sum\limits y_i \prod \limits_{i\neq j}\frac{n-x_j}{x_i-x_j}$ 。展开求和，第一第二项为 $y_1 \frac{(n-2)(n-3)\dots(n-K)}{(1-2)(1-3)\dots(1-K)},y_2 \frac{(n-1)(n-3)\dots(n-K)}{(2-1)(1-3)\dots(1-K)}$，分子分母分别维护前缀积后缀积即可。

  > $i^k$ ， $i^\underline{k}$ 与 阶乘、组合数
  >
  > 根据第二类斯特林数的定义，可把 $i^k$ 展开成 $\sum\limits_{j=0}^k\genfrac\{\}{0}{0}{k}{j}i^\underline{j}$ 。
  >
  > 对于 $i^\underline{k}$ ，是下降幂的形式。而阶乘 $t!$ 也是下降幂的形式，于是对于一般的阶乘 or 组合数，和下降幂的式子可以结合生成一些新的式子。比如 $\genfrac(){0}{0}{n}{i}i^\underline{j} = n^\underline{j}\genfrac(){0}{0}{n-j}{i-j}$ 。

  > 常用的**组合数公式**
  >
  > $\genfrac(){0}{0}{n}{i}\genfrac(){0}{0}{i}{j} = \genfrac(){0}{0}{n}{j}\genfrac(){0}{0}{n-j}{i-j}$ 。组合意义里，先选i后选j，和先选j后选i的等价变换。

  > 二项式 / 杨辉三角前缀和，组合数上下指标递推
  >
  > 令$f(x,y) = \sum\limits_{i=0}^y\genfrac(){0}{0}{x}{i}a^ib^{x-i}$ ，易看出是杨辉三角第x行的前y列求和。
  >
  > 这里简记 $b = 1$ ，此时 $f(x\pm 1,y),f(x,y\pm 1)$ 可以 $O(1)$ 计算。（a,b!=1时成立与否不确定，有可能不成立，慎用）。且若 $y > x$ ，考虑实际含义，其为杨辉三角的前y列求和，那么x行的x+1列以后的值为0，即 $f(x,y) = f(x,\min(x,y))$ 。
  >
  > 那么 $f(x,y) = \sum\limits_{i=0}^y\genfrac(){0}{0}{x}{i}a^i,y\leq x$ ，有 $f(x,y+1) = f(x,y) + \genfrac(){0}{0}{x}{y+1}a^{y+1}$ ，y-1同理。
  >
  > $f(x+1,y) = \sum\limits_{i=0}^y\genfrac(){0}{0}{x+1}{i}a^i = \sum\limits_{i=0}^y(\genfrac(){0}{0}{x}{i-1}+\genfrac(){0}{0}{x}{i})a^i = \sum\limits_{i=0}^y\genfrac(){0}{0}{x}{i-1}a^i+\sum\limits_{i=0}^y\genfrac(){0}{0}{x}{i}a^i$
  >
  > $= \sum\limits_{i=0}^{y-1}\genfrac(){0}{0}{x}{i}a^{i+1}+\sum\limits_{i=0}^y\genfrac(){0}{0}{x}{i}a^i = \sum\limits_{i=0}^{y}\genfrac(){0}{0}{x}{i}a^{i+1}+\sum\limits_{i=0}^y\genfrac(){0}{0}{x}{i}a^i - \genfrac(){0}{0}{x}{y}a^{y+1}$
  >
  > $ = (a+1)f(x,y) - \genfrac(){0}{0}{x}{y}a^{y+1}$
  >
  > 根据上面亦可知，组合数上下指标递推也是常数级别的，相对来说更好写。

  > $O(k)$ 求 $i^k$ 
  >
  > $i^k$ 是完全积性函数，所以可以直接上线性筛。仅需要在i为质数时求快速幂，其余的，直接 $(i*p)^k = i^k * p^k$ 。

- $\ln'(1-f(x)) = \sum-\frac{f^i(x)}{i},e'^{f(x)} = \sum \frac{f^i(x)}{i!}$ （这个有点弱智。。麦克劳林展开式把x代成f(x)即可，随时删掉）

- **可重排列** ：$\frac{n!}{\prod a_i!}$

- **OGF闭形式** ：$1+x+x^2+\dots = \frac{1}{1-x}$ ； **EGF闭形式** ： $1+x+\frac{x^2}{2!}+\dots = e^x$。与$\frac{1}{1-ax^t}$形式类似的为OGF；与$\sin,\cos,\ln,\frac{e^x\pm e^{-x}}{2}$形式类似的为EGF。

- **两个EGF相乘的意义** ： 考虑其中两项，$\frac{x^3}{3!},\frac{6x^5}{5!}$，乘起来为$6 * \frac{\frac{8!}{3!5!}}{8!}x^8$，此时$6 * \frac{8!}{5!3!}$即为两状态的可重排列的方案数。

- **置换环** ：一个排列经若干个置换环映射一次后恢复为康托序为0的排列。令$P_i\rightarrow i$，可知任意一个排列会形成数量 $\leq n$ 的置换环。根据此，有： $f$ 为全排列的EGF， $g$ 为圆排列的EGF，则 $f = e^g$ （比如大小为4的全排列为 $[x^4] \sum\limits_{i=1}^4 \frac{g^i}{i!}$）。注意$[x^0]g = 0$。类似的，【有标号树->森林】【有标号连通图->无向图】也是这类关系。

- **错排数** ：指规模为n的排列，$P_i\neq i$ 。可知置换环的大小均大于1。置换环的EGF为 $g = \sum\limits_{i>1}\frac{x^i}{i}$ ，则错排数的EGF为 $e^g$ 。

- **递增阶乘** ： $x^{(n)} = x^{\overline{n}} = x(x+1)(x+2)...(x+n-1)$ ；**递减阶乘** ： $(x)_n = x^{\underline{n}} = x(x-1)(x-2)...(x-n+1)$

- **有符号第一类斯特林数定义** ： $(x)_{n}=\sum_{k=0}^{n} s(n, k) x^{k}$ ； **无符号第一类斯特林数定义** ： $(x)^{\bar{n}}=\sum_{k=0}^{n}\left[\begin{array}{l}n \\ k\end{array}\right] x^{k}$ 。两者转化： $s(n, k)=(-1)^{n-k}\left[\begin{array}{l}n \\ k\end{array}\right]$ 。**无符号第一类斯特林数递推式** ： $\left[\begin{array}{l}n \\ k\end{array}\right]=\left[\begin{array}{l}n-1 \\ k-1\end{array}\right]+(n-1)\left[\begin{array}{c}n-1 \\ k\end{array}\right]$ ，表示n个互不相等元素形成k个圆排列的方案数。 

- **第二类斯特林数的定义** ： $x^{n}=\sum_{k=0}^{n}\left\{\begin{array}{l}n \\ k\end{array}\right\}x^{\underline{k}}$ 。**第二类斯特林数递推式** ： $\left\{\begin{array}{l}
  n \\
  k
  \end{array}\right\}=\left\{\begin{array}{l}
  n-1 \\
  k-1
  \end{array}\right\}+k\left\{\begin{array}{c}
  n-1 \\
  k
  \end{array}\right\}$ ，表示n个互不相等元素形成k个非空集合的方案数。
  
- $\genfrac[]{0}{0}{i}{j}$中，i叫行，j叫列。求$\genfrac[]{0}{0}{n}{j}$叫求行，求$\genfrac[]{0}{0}{i}{n}$叫求列。

- （第二类）**斯特林数公式** ： $\left\{\begin{array}{l} n \\ k \end{array}\right\} = \sum\limits_{i=0}^{k}\frac{(-1)^i}{i!}\frac{(k-i)^n}{(k-i)!}$ 。另有组合数变形： $k!\genfrac\{\}{0}{0}{n}{k} = \sum\limits_{i=0}^k(k-i)^n\genfrac(){0}{0}{k}{i}$。

- **第一类斯特林数 · 行** ： 根据 $(x)^{n}=\sum_{k=0}^{n} S(n, k) x^{k}$ 进行计算。考虑倍增，有两条式子， $x^{\overline{2n}} = x^{\overline{n}} * (x+n)^{\overline{n}},x^{\overline{n+1}}  =x^{\overline{n}} * (x+n)$。第二条式子$f_{i+1} = f_i + n*f_{i+1}$，线性求得。考虑$f(x) = x^{\overline{n}} = \sum\limits_{i=0}a_i x^i,g(x) = (x+n)^{\overline{n}} = \sum\limits_{i=0}a_i(x+n)^i$。考虑对于 $(x+n)^i$ 展开后对每一项的贡献： $[x^i]g(x) = \sum\limits_{j=0}a_j\genfrac(){0}{0}{j}{i}n^{j-i} = \sum\limits_{j=0}a_j\frac{j!}{i!(j-i)!}n^{j-i}$，即 $i![x^i]g(x) = \sum\limits_{j=0}a_jj!\frac{n^{j-i}}{(j-i)!}$。用卷积搞定。求得 $g$ 后跟 $f$ 再卷一次。 复杂度 $T(n) = T(n/2) + O(n\log n) \rightarrow O(n\log n)$。

- **第一类斯特林数 · 列** ：形成 k 个非空圆排列，则对应的EGF为 $G = \frac{F^k}{k!}$ ，其中 $F$ 为圆排列EGF，$F = \sum\frac{x^i}{i} $，求多项式k次方得到答案。

- **第二类斯特林数 · 行** ：根据公式 $\genfrac\{\}{0}{0}{n}{k} = \sum\limits_{i=0}^k\frac{(-1)^i}{i!}\frac{(k-i)^n}{(k-i)!}$ 求得。

- **第二类斯特林数 · 列** ：形成 k 个非空集合，对应EGF为 $G = \frac{F^k}{k!}$ ，其中 $F$ 为普通EGF， $F = \sum\limits_{i>0} \frac{x^i}{i!} = e^x - 1$ ，求多项式k次方得到答案。 

- **子集卷积** ：求解下标运算两个子集为划分的卷积 $c_{k}=\sum\limits_{i \& j=0 \atop i \mid j=k} a_{i} b_{j}$ 。令 $f_{i, j}=\left\{\begin{array}{l}a_{j}(|j|=i) \\ 0\end{array}, g_{i, j}=\left\{\begin{array}{l}b_{j}(|j|=i) \\ 0\end{array}\right.\right.$ ， $h_{i}=\sum\limits_{k=0}^{i} f_{k} * g_{i-k}$ ，此时的 $h_{|i|,i}$ 满足 $|i| + |j| = |i \cup j|$ 。但还需满足 $i | j = k$ 。故先让 $f_i,g_j$ 进行FWT卷积，再利用FWT，IFWT具有可加性，求出 $h_{i}=\sum\limits_{k=0}^{i} \operatorname{FWT}(f_{k}) * \operatorname{FWT}(g_{i-k})$ ，将 $h_i$ 进行IFWT卷积，此时 $h_{|i|,i}$ 即为 $c_i$ 。

- **构造prufer序列** ：考虑一个将 n 个连通块，每个连通块大小为 a_i ，将 n 个连通块连成一颗有标号无根树的方案数。枚举每个连通块的度（这里的度是实际的度-1，因为必须度>0，或者换个角度，就是枚举prufer的 d_i 个数），答案即为 $\sum\limits_{\sum d_i = n-2} \frac{(n-2)!}{\prod d_i!} \prod_j a_j^{d_j+1}$ 。

### 数论

- **剩余系** ，一个数集取模后两两不相等，则 **该数集** 称作剩余系 。令模为p， **完全剩余系** 的集合里有p个数。 **简化剩余系** 中则只含 $\varphi(p)$ 个与p互质的数。
- **求一个原根**：设 $p_{1}, p_{2}, \cdots, p_{k}$ 是 $\varphi(p)$ 所有两两不同的素因数, 则 $g$ 是 $p$ 的原根，当且仅当对 $i\in[1,k]$，有 $g^{\frac{\varphi(p)}{p_{i}}} \not \equiv 1(\bmod p)$ 。
- 当存在一个原根 $g$ ，则所有原根为 $\{g^s|s\in[1,\varphi(p)],(s,\varphi(p))=1\}$ （仅验证p为素数正确）实现方式可 $O(\varphi(p))$ 线筛：$p'=\varphi(p)$ ， $p_1,p_2,\dots,p_k$ 为 $p'$ 的质因子。类似线筛的过程，枚举倍数i（从1开始），指针j，去筛 `i*prime[j]` 。当 $i \equiv 0(\bmod p[j])$ ，退出，保证被筛数由最小质因子筛得。
- 线性筛只能从1开始筛，不能筛任意连续区间。可以用埃筛，复杂度$O(n\log n)$。
- 对于a，在模p下与a同阶的数个数为 $\varphi(\operatorname{ord}_pa)$ （仅验证p为素数正确）（结论形式与上一结论类似）
- **欧拉定理**：$a^\varphi(p)\equiv 1(\bmod p),(a,p)=1$。当p为质数有 **费马小定理** ：$a^{p-1}\equiv 1(\bmod p)$。
- **扩展欧拉定理**：$a^{c} \equiv\left\{\begin{array}{ll}
  a^{c \% \varphi(p)}, & \operatorname{gcd}(a, p)=1 \\
  a^{c}, & \operatorname{gcd}(a, p) \neq 1, c<\varphi(p) \quad(\bmod p) \\
  a^{c \% \varphi(p)+\varphi(p)}, & \operatorname{gcd}(a, p) \neq 1, c \geq \varphi(p)
  \end{array}\right.$
- 仅需找某个数的所有因子：调用Linux命令`factor x`，可以筛出所有x的因子。git bash实现了大部分linux指令，包括factor，故直接使用git bash。
- **求单个逆元** ：$ax+kp = 1$ ，用exgcd求解。逆元 $inv[i] = (p - \lfloor\frac{p}{i}\rfloor)*inv[p\bmod i]\bmod p $ 。
- 

## 字符串



## 计算几何



## 图论

### 网络流

- **有上下界的网络流** ： 即一些边至少流满L流量，至多流满R流量的模型。对于这种模型，在原图的边建R-L的边，然后对于点u的顶标-L，点v的顶标+L。对于包括源点S汇点T的点，当顶标>0，超级源SS向点u连顶标值大小流量的边。当顶标<0，u向超级汇TT连顶标值的绝对值流量的边。先跑一遍dinic(SS,TT)，然后连接<T,S,inf>，再跑一次dinic(SS,TT)，此时T->S的反边就是最小流Flow1（若此时从超级源SS的流量没流满，说明不存在合法的网络流）。之后去除T->S这条边（ `p[S] = edge[p[S]].next,p[T] = edge[p[T]].next` ），然后跑dinic(S,T)（由于原图可能没跑满），最大流就等于最小流Flow1加上dinic(S,T)的值。

### 树

- **求树上最小连通块** ：在树上标记S个点，求最小的连通块大小，使得该连通块包含所有标记点。首先将树预处理转化为有根树并求出dfs序。将标记点按照dfn序排序，每次对相邻两个点进行除lca的路径覆盖（即不覆盖lca）。最后将第1个点和第S个点进行除lca的路径覆盖。这样处理后，发现除了点1和点S的lca被覆盖0次，其余的最小连通块的点均被覆盖两次，此时除2，再加上点1和点S的lca。目前遇到的题目是求最小连通块的权值和，只需要预处理从根节点到当前节点的权值和u，将路径查询转为单点查询。
- **倍增求LCA与找k级祖先**：先把更深的点u提至与另一个点v相同深的位置（如果u=v直接返回），然后二进制拆分枚举k级祖先，以相同步长向上走，直到直接父节点为两个点的lca。倍增lca相比树剖lca的好处在于方便求k级祖先，使用jump函数。k = 0级祖先即为自己。

### 图

- 求 **图极大独立集** 与 **极大度数导出子图** ：

  > 考虑这么一个过程：
  >
  > 每次将图中最小度数的点u连同直接相连的点v删去。在这个过程中，每次的图中最小度数的点的度数就是整个图的最小度数mxp，保留它必然不是最优，故删去它。这个过程用分层queue维护，第i层queue维护度数为i的节点。即每次从最小度数的queue层进行删点，直至所有点删完。删掉的点就不重复删除了。复杂度 $O(n+m)$ 。
  >
  > 在这过程中最小度数mxp最大时，剩余的子图即为 **极大度数导出子图** ，而所有的 u 的集合即为 **图极大独立集** 。

- $2^n$ **枚举图独立集** ：

  > 令 blink[S] 表示：
  >
  > 除去点 i ，与点 i 相连的点集。具体的，有dp方程：
  > $$
  > blink[S] = blink[S \oplus (1llu<<i)]\ |\ link[m+i],i为二进制最小位的点
  > $$
  > 然后枚举点集 $S$ ，当 $blink[S]\ \&\ S = 0$ 时， S 即为独立集。